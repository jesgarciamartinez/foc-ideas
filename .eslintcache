[{"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/index.tsx":"1","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/ColorModeSwitcher.tsx":"2","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/serviceWorker.ts":"3","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/reportWebVitals.ts":"4","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/Sidebar.tsx":"5","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/App.tsx":"6","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/CardHStack.tsx":"7","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/TypeBadge.tsx":"8","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/FlowCard.tsx":"9","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/Card.tsx":"10","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/state.ts":"11","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/Editor.tsx":"12","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/PopoverExplanation.tsx":"13","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/EditableText.tsx":"14","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/theme.ts":"15","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/utils.js":"16","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/index.js":"17","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/autocomplete.js":"18","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/triggers.js":"19","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/data.js":"20","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/styles.js":"21","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/addsuggestion.js":"22","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/suggestions.js":"23","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/DocsCard/components.tsx":"24","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/DocsCard/DocsCard.tsx":"25"},{"size":953,"mtime":1607783634378,"results":"26","hashOfConfig":"27"},{"size":743,"mtime":1606395811243,"results":"28","hashOfConfig":"27"},{"size":5258,"mtime":1606395314403,"results":"29","hashOfConfig":"27"},{"size":416,"mtime":1606395314402,"results":"30","hashOfConfig":"27"},{"size":13504,"mtime":1608451943308,"results":"31","hashOfConfig":"27"},{"size":7041,"mtime":1608462478595,"results":"32","hashOfConfig":"27"},{"size":395,"mtime":1608112070153,"results":"33","hashOfConfig":"27"},{"size":1370,"mtime":1608321098960,"results":"34","hashOfConfig":"27"},{"size":13573,"mtime":1608451893708,"results":"35","hashOfConfig":"27"},{"size":605,"mtime":1606852903166,"results":"36","hashOfConfig":"27"},{"size":10657,"mtime":1608462866647,"results":"37","hashOfConfig":"27"},{"size":870,"mtime":1608005300285,"results":"38","hashOfConfig":"27"},{"size":1295,"mtime":1608457387478,"results":"39","hashOfConfig":"27"},{"size":393,"mtime":1607635865658,"results":"40","hashOfConfig":"27"},{"size":2081,"mtime":1608324466728,"results":"41","hashOfConfig":"27"},{"size":408,"mtime":1608130752557,"results":"42","hashOfConfig":"27"},{"size":2398,"mtime":1608157691253,"results":"43","hashOfConfig":"27"},{"size":8928,"mtime":1608177181752,"results":"44","hashOfConfig":"27"},{"size":441,"mtime":1608130752556,"results":"45","hashOfConfig":"27"},{"size":182,"mtime":1608130752554,"results":"46","hashOfConfig":"27"},{"size":742,"mtime":1608130752556,"results":"47","hashOfConfig":"27"},{"size":1086,"mtime":1608130752553,"results":"48","hashOfConfig":"27"},{"size":859,"mtime":1608142377987,"results":"49","hashOfConfig":"27"},{"size":5797,"mtime":1608462343537,"results":"50","hashOfConfig":"27"},{"size":23146,"mtime":1608460588689,"results":"51","hashOfConfig":"27"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"55"},"5rdob7",{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"63"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"73","messages":"74","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"77","messages":"78","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"89"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92","usedDeprecatedRules":"93"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"97"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"100","usedDeprecatedRules":"101"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"104"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"104"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"112","usedDeprecatedRules":"89"},{"filePath":"113","messages":"114","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"115","messages":"116","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"117"},"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/index.tsx",["118"],"import * as React from 'react'\nimport ReactDOM from 'react-dom'\nimport { ColorModeScript, extendTheme, ChakraProvider } from '@chakra-ui/react'\nimport { App } from './App'\nimport reportWebVitals from './reportWebVitals'\nimport * as serviceWorker from './serviceWorker'\nimport theme from './theme'\n\nReactDOM.render(\n  <React.StrictMode>\n    <ColorModeScript />\n    <ChakraProvider theme={theme}>\n      <App />\n    </ChakraProvider>\n  </React.StrictMode>,\n  document.getElementById('root'),\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorker.unregister()\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n",["119","120"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/ColorModeSwitcher.tsx",[],["121","122"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/serviceWorker.ts",[],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/reportWebVitals.ts",[],["123","124"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/Sidebar.tsx",["125","126","127"],"import * as React from 'react'\nimport { Droppable, Draggable } from 'react-beautiful-dnd'\nimport type { Ieffect, Itype, Ifunction } from './interfaces'\nimport {\n  Box,\n  Code,\n  forwardRef,\n  Input,\n  InputGroup,\n  InputLeftElement,\n  Text,\n  Kbd,\n  ListItem,\n  UnorderedList,\n  Center,\n  useTheme,\n  InputRightElement,\n  InputRightAddon,\n  HStack,\n} from '@chakra-ui/react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport TreeView from '@material-ui/lab/TreeView'\nimport TreeItem from '@material-ui/lab/TreeItem'\nimport {\n  ChevronDownIcon,\n  ChevronRightIcon,\n  ArrowForwardIcon,\n  SearchIcon,\n} from '@chakra-ui/icons'\nimport { FaShapes } from 'react-icons/fa'\n// import { VscSymbolMisc as FaShapes } from 'react-icons/vsc'\nimport { GiMineExplosion } from 'react-icons/gi'\n// import { IoShapes } from 'react-icons/io' //RiFunctionLine, RiFunctionFill //IoShapesOutline\nimport './sideBarStyles.css'\nimport TypeBadge from './TypeBadge'\nimport { Action } from '../state'\nimport MouseTrap from 'mousetrap'\n// import { FlowFunctionView } from './FlowCard'\nimport PopoverExplanation from './PopoverExplanation'\n\ntype IsideBarItem =\n  | {\n      nodeId: 'functions'\n      label: 'Functions'\n      items: Array<Ifunction>\n    }\n  | {\n      nodeId: 'types'\n      label: 'Data Types'\n      items: Array<Itype>\n    }\n  | {\n      nodeId: 'effects'\n      label: 'Effects'\n      items: Array<Ieffect>\n    }\n\nexport const FunctionItem = (props: Ifunction) => {\n  return (\n    <Text\n      wrap='nowrap'\n      color='unison.purple'\n      _hover={{ color: 'unison.lightPurple' }}\n    >\n      <Code\n        fontSize='sm'\n        // fontWeight='700'\n        paddingX={1}\n        paddingY={0.5}\n        rounded='base'\n        backgroundColor='transparent'\n        color='inherit'\n      >\n        {props.name}\n      </Code>\n      <Text as='span'>: </Text>\n      <Text as={'span'} flexWrap='nowrap'>\n        {props.parameters.map((p, i) => (\n          <Text as='span' key={i}>\n            <TypeBadge typeAsString={p.type} />\n            <ArrowForwardIcon marginX={1} />\n          </Text>\n        ))}\n      </Text>\n      <TypeBadge typeAsString={props.returns.type} />\n    </Text>\n  )\n}\n\nconst getFunctionRenderItem = (props: Ifunction) => (\n  provided: any,\n  snapshot: any,\n  rubric: any,\n) => {\n  return (\n    <div\n      {...provided.draggableProps}\n      {...provided.dragHandleProps}\n      ref={provided.innerRef}\n      style={provided.draggableProps.style}\n    >\n      <div>\n        <FunctionItem {...props} />\n        {/* <FlowFunctionView item={{ ...props }} /> */}\n      </div>\n    </div>\n  )\n}\nconst useTreeItemStyles = makeStyles({\n  root: {\n    marginBottom: '5px',\n  },\n  content: {\n    '&:hover': {\n      backgroundColor: 'transparent',\n      cursor: 'grabbing',\n    },\n  },\n})\n\nconst FunctionTreeItem = (\n  props: Ifunction & { nodeId: string; isAnyItemDragging: boolean },\n) => {\n  const { root, content } = useTreeItemStyles()\n  return (\n    <TreeItem\n      classes={{ root, content: props.isAnyItemDragging ? content : undefined }}\n      nodeId={props.nodeId}\n      label={\n        <Droppable\n          droppableId={props.nodeId}\n          renderClone={getFunctionRenderItem(props)}\n          isDropDisabled={true}\n        >\n          {(provided, snapshot) => {\n            const shouldRenderClone =\n              props.nodeId === snapshot.draggingFromThisWith\n            return (\n              <div ref={provided.innerRef} {...provided.droppableProps}>\n                {shouldRenderClone ? (\n                  <div className='react-beautiful-dnd-copy'>\n                    <FunctionItem {...props}></FunctionItem>\n                  </div>\n                ) : (\n                  <Draggable draggableId={props.nodeId} index={0}>\n                    {(provided, snapshot) => {\n                      return (\n                        <div\n                          ref={provided.innerRef}\n                          {...provided.draggableProps}\n                          {...provided.dragHandleProps}\n                        >\n                          <FunctionItem {...props}></FunctionItem>\n                        </div>\n                      )\n                    }}\n                  </Draggable>\n                )}\n                {/* {provided.placeholder} */}\n              </div>\n            )\n          }}\n        </Droppable>\n      }\n    ></TreeItem>\n  )\n}\nconst TypeTreeItem = (\n  props: Itype & { nodeId: string; isAnyItemDragging: boolean },\n) => {\n  const { content } = useTreeItemStyles()\n  return (\n    <TreeItem\n      nodeId={props.nodeId}\n      classes={{ content: props.isAnyItemDragging ? content : undefined }}\n      label={<TypeBadge typeAsString={props.type}></TypeBadge>}\n    />\n  )\n}\n\nconst Sidebar = React.memo(\n  forwardRef(\n    (\n      {\n        items,\n        isAnyItemDragging,\n        dispatch,\n        searchValue,\n      }: {\n        items: Array<IsideBarItem>\n        isAnyItemDragging: boolean\n        dispatch: React.Dispatch<Action>\n        searchValue: string\n      },\n      ref,\n    ) => {\n      const theme = useTheme()\n      const {\n        colors: {\n          unison: { purple, lightPurple, aqua },\n        },\n      } = theme\n\n      //Search\n      const [isHoveringSearch, setIsHoveringSearch] = React.useState(false)\n      const [isFocusedSearch, setFocusedSearch] = React.useState(false)\n      const onMouseEnterSearch = React.useCallback(() => {\n        setIsHoveringSearch(true)\n      }, [])\n      const onMouseLeaveSearch = React.useCallback(() => {\n        setIsHoveringSearch(false)\n      }, [])\n\n      return (\n        <Box\n          height='100%'\n          flex={1}\n          backgroundColor={'purple.50'}\n          paddingTop={4}\n        >\n          <InputGroup\n            width='100%'\n            whiteSpace='nowrap'\n            padding={1}\n            display='flex'\n            onMouseEnter={onMouseEnterSearch}\n            onMouseLeave={onMouseLeaveSearch}\n            // _focusWithin={{ color: 'teal.600' }}\n          >\n            <InputLeftElement\n              pointerEvents='none'\n              children={\n                <SearchIcon\n                  color={\n                    isFocusedSearch\n                      ? aqua\n                      : isHoveringSearch\n                      ? lightPurple\n                      : purple\n                  }\n                />\n              } //TODO teal\n            />\n            <Input\n              ref={ref}\n              placeholder='Search'\n              variant='outline'\n              _hover={{ borderBottomColor: lightPurple }}\n              focusBorderColor={'unison.aqua'}\n              size='md'\n              borderRadius='0%'\n              borderTop='none'\n              borderLeft='none'\n              borderRight='none'\n              borderBottom={`2px solid ${purple}`}\n              value={searchValue}\n              onFocus={() => {\n                if (!ref || !('current' in ref)) return\n                ref.current.setSelectionRange(0, ref.current.value.length)\n                setFocusedSearch(true)\n              }}\n              onBlur={() => setFocusedSearch(false)}\n              onChange={e =>\n                dispatch({ type: 'sideBarSearch', value: e.target.value })\n              }\n            />\n            {isHoveringSearch ? (\n              <HStack\n                background='transparent'\n                position='absolute'\n                right={2}\n                top={2}\n                pointerEvents='none'\n              >\n                <Kbd>ctrl</Kbd>\n                <Text>/</Text>\n                <Kbd>⌘</Kbd>\n                <Text>+</Text>\n                <Kbd>B</Kbd>\n              </HStack>\n            ) : null}\n          </InputGroup>\n          <Center>\n            <PopoverExplanation label='Sidebar explanation' title='Sidebar'>\n              <UnorderedList>\n                <ListItem>\n                  Drag functions and drop them onto Flow Card or Docs Card\n                </ListItem>\n                <ListItem>\n                  <Kbd>up</Kbd>, <Kbd>down</Kbd>, <Kbd>left</Kbd>,{' '}\n                  <Kbd>right</Kbd> to move in Sidebar\n                </ListItem>\n                <ListItem>\n                  <Kbd>space</Kbd> to drag, <Kbd>right</Kbd> then{' '}\n                  <Kbd>space</Kbd> to drop\n                </ListItem>\n                <ListItem>\n                  Datatypes and Effects are not interactive at this point\n                </ListItem>\n              </UnorderedList>\n            </PopoverExplanation>\n          </Center>\n\n          <TreeView\n            selected={[]}\n            aria-label='Functions, types and effects'\n            defaultCollapseIcon={<ChevronDownIcon color='unison.purple' />}\n            defaultExpandIcon={<ChevronRightIcon color='unison.purple' />}\n            onNodeFocus={(e, v) => {\n              const draggable: any = document.querySelector(\n                `[data-rbd-draggable-id=\"${v}\"]`,\n              )\n\n              if (draggable) {\n                const focused = document.querySelectorAll('.Mui-focused')\n                focused.forEach(e => {\n                  e.classList.remove('Mui-focused')\n                })\n                const div =\n                  draggable.parentElement?.parentElement?.parentElement\n                const li = div?.parentElement\n                const parentMenu =\n                  li?.parentElement?.parentElement?.parentElement?.parentElement\n                const previous = li?.previousElementSibling\n                const next = li?.nextElementSibling\n\n                if (!draggable.bound) {\n                  draggable.bound = true\n                  MouseTrap(draggable).bind('left', e => {\n                    if (isAnyItemDragging) {\n                      return\n                    }\n                    div?.classList.remove('Mui-focused')\n                    parentMenu?.focus()\n                  })\n                  MouseTrap(draggable).bind('down', e => {\n                    if (isAnyItemDragging) {\n                      return\n                    }\n                    if (next) {\n                      next.focus()\n                      div?.classList.remove('Mui-focused')\n                    } else {\n                      parentMenu?.nextElementSibling?.focus()\n                      div?.classList.remove('Mui-focused')\n                    }\n                  })\n                  MouseTrap(draggable).bind('up', e => {\n                    if (isAnyItemDragging) {\n                      return\n                    }\n                    if (previous) {\n                      previous.focus()\n                      div?.classList.remove('Mui-focused')\n                    } else {\n                      parentMenu?.focus()\n                      div?.classList.remove('Mui-focused')\n                    }\n                  })\n                }\n\n                div?.classList.add('Mui-focused')\n                draggable.focus()\n              }\n            }}\n          >\n            {items &&\n              items.map(item => {\n                const label = (\n                  <Text fontSize='lg' color={'unison.purple'}>\n                    {item.label}\n                  </Text>\n                )\n                return (\n                  <TreeItem\n                    nodeId={item.nodeId}\n                    key={item.nodeId}\n                    label={\n                      <HStack>\n                        {item.nodeId === 'functions' ? (\n                          <Text fontWeight='bold' fontSize='xl' color={purple}>\n                            λ\n                          </Text>\n                        ) : item.nodeId === 'types' ? (\n                          <FaShapes color={purple} />\n                        ) : item.nodeId === 'effects' ? (\n                          <GiMineExplosion color={purple} />\n                        ) : null}\n                        {label}\n                      </HStack>\n                    }\n                  >\n                    {(() => {\n                      switch (item.nodeId) {\n                        case 'functions':\n                          return item.items.map(innerItem => {\n                            const id = `${item.nodeId}_${innerItem.name}`\n                            return (\n                              <FunctionTreeItem\n                                {...innerItem}\n                                key={id}\n                                nodeId={id}\n                                isAnyItemDragging={!!isAnyItemDragging}\n                              />\n                            )\n                          })\n                        case 'types':\n                          return item.items.map(innerItem => {\n                            const id = `${item.nodeId}_${innerItem.type}`\n                            return (\n                              <TypeTreeItem\n                                {...innerItem}\n                                key={id}\n                                nodeId={id}\n                                isAnyItemDragging={!!isAnyItemDragging}\n                              />\n                            )\n                          })\n                        case 'effects':\n                          return null //@TODO\n                        default:\n                          let _: never = item\n                      }\n                    })()}\n                  </TreeItem>\n                )\n              })}\n          </TreeView>\n        </Box>\n      )\n    },\n  ),\n)\n\nexport default Sidebar\n","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/App.tsx",["128"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/CardHStack.tsx",[],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/TypeBadge.tsx",["129","130"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/FlowCard.tsx",["131","132","133","134","135","136","137","138","139","140"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/Card.tsx",[],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/state.ts",["141","142"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/Editor.tsx",[],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/PopoverExplanation.tsx",["143"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/EditableText.tsx",[],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/theme.ts",[],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/utils.js",[],["144","145"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/index.js",["146","147","148","149","150"],"import { Entity, Modifier, Editor, EditorState } from 'draft-js'\nimport * as React from 'react'\nimport { AutocompleteEditor } from './autocomplete'\nimport SuggestionList from './suggestions'\nimport styles from './styles'\nimport { normalizeIndex, filterArray } from './utils'\nimport * as triggers from './triggers'\nimport * as data from './data'\nimport addSuggestion from './addsuggestion'\n\nvar filteredArrayTemp\n\nexport default class AutocompleteInput extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      editorState: EditorState.createEmpty(),\n      autocompleteState: null,\n    }\n\n    this.onChange = editorState =>\n      this.setState({\n        editorState,\n      })\n\n    this.onAutocompleteChange = autocompleteState =>\n      this.setState({\n        autocompleteState,\n      })\n\n    this.onInsert = insertState => {\n      if (!filteredArrayTemp) {\n        return null\n      }\n      const index = normalizeIndex(\n        insertState.selectedIndex,\n        filteredArrayTemp.length,\n      )\n      insertState.text = insertState.trigger + filteredArrayTemp[index]\n      return addSuggestion(insertState)\n    }\n  }\n\n  renderAutocomplete() {\n    //left, top, array, selectedIndex, type, text\n    const { autocompleteState, onSuggestionClick } = this.state\n    if (!autocompleteState) {\n      return null\n    }\n    filteredArrayTemp = this.getFilteredArray(\n      autocompleteState.type,\n      autocompleteState.text,\n    )\n    autocompleteState.array = filteredArrayTemp\n    // autocompleteState.onSuggestionClick = this.onSuggestionItemClick\n    return <SuggestionList suggestionsState={autocompleteState} />\n  }\n\n  getFilteredArray(type, text) {\n    const dataArray = type == triggers.PERSON ? data.persons : data.tags\n    const filteredArray = filterArray(\n      dataArray,\n      text.replace(triggers.regExByType(type), ''),\n    )\n    return filteredArray\n  }\n\n  render() {\n    return (\n      <div style={styles.root}>\n        {' '}\n        {this.renderAutocomplete()}{' '}\n        <div style={styles.editor}>\n          <AutocompleteEditor\n            editorState={this.state.editorState}\n            onChange={this.onChange}\n            onAutocompleteChange={this.onAutocompleteChange}\n            onInsert={this.onInsert}\n          />{' '}\n        </div>{' '}\n      </div>\n    )\n  }\n}\n\n// render( < AutocompleteInput / > ,\n//   document.getElementById('app')\n// );\n",["151","152"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/autocomplete.js",["153","154","155","156","157","158","159","160","161","162","163","164"],"import { render } from 'react-dom'\nimport React from 'react'\nimport { Editor, EditorState } from 'draft-js'\nimport styles from './styles'\nimport * as triggers from './triggers'\n\nexport class AutocompleteEditor extends Editor {\n  constructor(props) {\n    super(props)\n    this.autocompleteState = null\n\n    this.onChange = editorState => {\n      const { onChange, onAutocompleteChange } = this.props\n      onChange(editorState)\n      if (onAutocompleteChange) {\n        window.requestAnimationFrame(() => {\n          onAutocompleteChange(this.getAutocompleteState())\n        })\n      }\n    }\n\n    this.onArrow = (e, originalHandler, nudgeAmount) => {\n      const { onAutocompleteChange } = this.props\n      let autocompleteState = this.getAutocompleteState(false)\n      if (!autocompleteState) {\n        if (originalHandler) {\n          originalHandler(e)\n        }\n        return\n      }\n\n      e.preventDefault()\n      autocompleteState.selectedIndex += nudgeAmount\n      this.autocompleteState = autocompleteState\n      if (onAutocompleteChange) {\n        onAutocompleteChange(autocompleteState)\n      }\n    }\n\n    this.onUpArrow = e => {\n      this.onArrow(e, this.props.onUpArrow, -1)\n      const contentState = this.props.editorState.getCurrentContent()\n    }\n\n    this.onDownArrow = e => {\n      this.onArrow(e, this.props.onDownArrow, 1)\n    }\n\n    this.onEscape = e => {\n      const { onEscape, onAutocompleteChange } = this.props\n\n      if (!this.getAutocompleteState(false)) {\n        if (onEscape) {\n          onEscape(e)\n        }\n        return\n      }\n\n      e.preventDefault()\n      this.autocompleteState = null\n\n      if (onAutocompleteChange) {\n        onAutocompleteChange(null)\n      }\n    }\n\n    this.onTab = e => {\n      this.commitSelection(e)\n    }\n\n    this.handleReturn = e => {\n      return this.commitSelection(e)\n    }\n  }\n\n  commitSelection(e) {\n    const { onAutocompleteChange } = this.props\n    let autocompleteState = this.getAutocompleteState(false)\n    if (!autocompleteState) {\n      return false\n    }\n    e.preventDefault()\n    this.onMentionSelect()\n    this.autocompleteState = null\n\n    if (onAutocompleteChange) {\n      onAutocompleteChange(null)\n    }\n    return true\n  }\n\n  onMentionSelect() {\n    let autocompleteState = this.getAutocompleteState(false)\n    const { editorState } = this.props\n    const insertState = this.getInsertState(\n      autocompleteState.selectedIndex,\n      autocompleteState.trigger,\n    )\n    const { onInsert } = this.props\n    const newEditorState = onInsert(insertState)\n    const { onChange } = this.props\n    onChange(newEditorState)\n  }\n\n  getInsertState(selectedIndex, trigger) {\n    const { editorState } = this.props\n    const currentSelectionState = editorState.getSelection()\n    const end = currentSelectionState.getAnchorOffset()\n    const anchorKey = currentSelectionState.getAnchorKey()\n    const currentContent = editorState.getCurrentContent()\n    const currentBlock = currentContent.getBlockForKey(anchorKey)\n    const blockText = currentBlock.getText()\n    const start = blockText.substring(0, end).lastIndexOf(trigger)\n    return {\n      editorState,\n      start,\n      end,\n      trigger,\n      selectedIndex,\n    }\n  }\n\n  hasEntityAtSelection() {\n    const { editorState } = this.props\n\n    const selection = editorState.getSelection()\n    if (!selection.getHasFocus()) {\n      return false\n    }\n\n    const contentState = editorState.getCurrentContent()\n    const block = contentState.getBlockForKey(selection.getStartKey())\n    return !!block.getEntityAt(selection.getStartOffset() - 1)\n  }\n\n  getAutocompleteRange(trigger) {\n    const selection = window.getSelection()\n    if (selection.rangeCount === 0) {\n      return null\n    }\n\n    if (this.hasEntityAtSelection()) {\n      return null\n    }\n\n    const range = selection.getRangeAt(0)\n    let text = range.startContainer.textContent\n    text = text.substring(0, range.startOffset)\n    const index = text.lastIndexOf(trigger)\n    if (index === -1) {\n      return null\n    }\n    text = text.substring(index)\n    return {\n      text,\n      start: index,\n      end: range.startOffset,\n    }\n  }\n\n  getAutocompleteState(invalidate = true) {\n    if (!invalidate) {\n      return this.autocompleteState\n    }\n\n    const tagRange = this.getAutocompleteRange(triggers.TAG_TRIGGER)\n    const personRange = this.getAutocompleteRange(triggers.PERSON_TRIGGER)\n    if (!tagRange && !personRange) {\n      this.autocompleteState = null\n      return null\n    }\n    var type = null\n    var trigger = null\n    var range = null\n    if (!tagRange) {\n      range = personRange\n      type = triggers.PERSON\n      trigger = triggers.PERSON_TRIGGER\n    }\n\n    if (!personRange) {\n      range = tagRange\n      type = triggers.TAG\n      trigger = triggers.TAG_TRIGGER\n    }\n\n    if (!range) {\n      range = tagRange.start > personRange.start ? tagRange : personRange\n      type = tagRange.start > personRange.start ? triggers.TAG : triggers.PERSON\n      trigger =\n        tagRange.start > personRange.start\n          ? triggers.TAG_TRIGGER\n          : triggers.PERSON_TRIGGER\n    }\n\n    const tempRange = window.getSelection().getRangeAt(0).cloneRange()\n    tempRange.setStart(tempRange.startContainer, range.start)\n\n    const rangeRect = tempRange.getBoundingClientRect()\n    let [left, top] = [rangeRect.left, rangeRect.bottom]\n\n    this.autocompleteState = {\n      trigger,\n      type,\n      left,\n      top,\n      text: range.text,\n      selectedIndex: 0,\n    }\n    console.log(this.autocompleteState)\n    return this.autocompleteState\n  }\n\n  ///\n\n  getAutocompleteState(invalidate = true) {\n    if (!invalidate) {\n      return this.autocompleteState\n    }\n    var type = null\n    var trigger = null\n    //Get range for latest hash tag trigger symbol.\n    const tagRange = this.getAutocompleteRange(triggers.TAG_TRIGGER)\n    //Get range for latest mention tag trigger symbol.\n    const personRange = this.getAutocompleteRange(triggers.PERSON_TRIGGER)\n    //Find what trigger is latest.\n    if (!tagRange && !personRange) {\n      this.autocompleteState = null\n      return null\n    }\n    var range = null\n    if (!tagRange) {\n      range = personRange\n      type = triggers.PERSON\n      trigger = triggers.PERSON_TRIGGER\n    }\n    if (!personRange) {\n      range = tagRange\n      type = triggers.TAG\n      trigger = triggers.TAG_TRIGGER\n    }\n    if (!range) {\n      range = tagRange.start > personRange.start ? tagRange : personRange\n      type = tagRange.start > personRange.start ? triggers.TAG : triggers.PERSON\n      trigger =\n        tagRange.start > personRange.start\n          ? triggers.TAG_TRIGGER\n          : triggers.PERSON_TRIGGER\n    }\n    //Get left and top coordinates of range.\n    //This point will be used to draw suggestion list.\n    const tempRange = window.getSelection().getRangeAt(0).cloneRange()\n    tempRange.setStart(tempRange.startContainer, range.start)\n    const rangeRect = tempRange.getBoundingClientRect()\n    let [left, top] = [rangeRect.left, rangeRect.bottom]\n    //Create autocompleteState.\n    this.autocompleteState = {\n      trigger, //Trigger symbol. “@” or “#”\n      type, //Type of trigger. Can be TAG or PERSON.\n      left, //The left point of range.\n      top, //The top point of range.\n      text: range.text, //Current text in selected range.\n      selectedIndex: 0, //Selected index in list. 0 for new list.\n    }\n    return this.autocompleteState\n  }\n  //Get range of possible mention or hashtag.\n  getAutocompleteRange(trigger) {\n    const selection = window.getSelection()\n    if (selection.rangeCount === 0) {\n      return null\n    }\n    if (this.hasEntityAtSelection()) {\n      return null\n    }\n    const range = selection.getRangeAt(0)\n    let text = range.startContainer.textContent\n    text = text.substring(0, range.startOffset)\n    const index = text.lastIndexOf(trigger)\n    if (index === -1) {\n      return null\n    }\n    text = text.substring(index)\n    return {\n      text,\n      start: index,\n      end: range.startOffset,\n    }\n  }\n\n  hasEntityAtSelection() {\n    const { editorState } = this.props\n    const selection = editorState.getSelection()\n    //If there is no focus, return.\n    if (!selection.getHasFocus()) {\n      return false\n    }\n    const contentState = editorState.getCurrentContent()\n    const block = contentState.getBlockForKey(selection.getStartKey())\n    return !!block.getEntityAt(selection.getStartOffset() - 1)\n  }\n\n  ///\n  render() {\n    const {\n      onChange,\n      editorState,\n      onEscape,\n      onUpArrow,\n      onDownArrow,\n      onAutocompleteChange,\n    } = this.props\n\n    return (\n      <Editor\n        customStyleMap={styles}\n        editorState={editorState}\n        handleReturn={this.handleReturn}\n        onChange={this.onChange}\n        onEscape={this.onEscape}\n        onUpArrow={this.onUpArrow}\n        onDownArrow={this.onDownArrow}\n        onTab={this.onTab}\n      />\n    )\n  }\n}\n",["165","166"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/triggers.js",["167","168"],"export const TAG = 1;\nexport const PERSON = 2;\nexport const RELATIONS = 3;\nexport const TAG_TRIGGER = '#';\nexport const PERSON_TRIGGER = '@';\nexport const RELATIONS_TRIGGER = '<';\n\n\nexport const TAG_REG_EX = /^#/;\nexport const PERSON_REG_EX = /^@/;\n\n\nexport const triggerByType = (type) => {\n  return type == TAG ? TAG_TRIGGER : PERSON_TRIGGER;\n};\n\nexport const regExByType = (type) => {\n  return type == TAG ? TAG_REG_EX : PERSON_REG_EX;\n};",["169","170"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/data.js",[],["171","172"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/styles.js",[],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/addsuggestion.js",["173"],"import { Entity, Modifier, Editor, EditorState } from 'draft-js';\n\nconst addSuggestion = ({editorState, start, end, trigger, text}) => {\n  const entityKey = Entity.create('MENTION', 'IMMUTABLE', \"http://vk.com\");\n  const currentSelectionState = editorState.getSelection();\n  const mentionTextSelection = currentSelectionState.merge({\n    anchorOffset: start,\n    focusOffset: end\n  });\n\n  let insertingContent = Modifier.replaceText(\n    editorState.getCurrentContent(),\n    mentionTextSelection,\n    text, ['link', 'BOLD'],\n    entityKey\n  );\n\n  const blockKey = mentionTextSelection.getAnchorKey();\n  const blockSize = editorState.getCurrentContent().getBlockForKey(blockKey).getLength();\n  if (blockSize === end) {\n    insertingContent = Modifier.insertText(\n      insertingContent,\n      insertingContent.getSelectionAfter(),\n      ' '\n    );\n  }\n\n  const newEditorState = EditorState.push(\n    editorState,\n    insertingContent,\n    'insert-mention'\n  );\n\n  return EditorState.forceSelection(newEditorState, insertingContent.getSelectionAfter());\n};\n\n\nexport default addSuggestion;","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/autocomplete-react-draft/src/suggestions.js",["174"],"import styles from './styles'\nimport { render } from 'react-dom'\nimport React from 'react'\nimport { normalizeIndex } from './utils'\n\nconst SuggestionList = props => {\n  const { suggestionsState } = props\n  const { left, top, array, selectedIndex } = suggestionsState\n\n  const style = Object.assign({}, styles.suggestions, {\n    position: 'absolute',\n    left,\n    top,\n  })\n  if (!array) {\n    return null\n  }\n  const normalizedIndex = normalizeIndex(selectedIndex, array.length)\n  return (\n    <ul style={style}>\n      {' '}\n      {array.map((person, index) => {\n        const style =\n          index === normalizedIndex ? styles.selectedPerson : styles.person\n        return (\n          <li key={person} style={style}>\n            {' '}\n            {person}{' '}\n          </li>\n        )\n      }, this)}{' '}\n    </ul>\n  )\n}\n\nexport default SuggestionList\n","/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/DocsCard/components.tsx",["175","176","177"],"/Users/jesusgarciamartinez/Desktop/new-documents/projects/unison-job-application/my-app/src/components/DocsCard/DocsCard.tsx",["178","179","180","181","182","183","184","185","186","187"],"import * as React from 'react'\nimport {\n  HStack,\n  Editable,\n  EditablePreview,\n  EditableInput,\n  Text,\n  Code,\n  IconButton,\n  Box,\n  Divider,\n  Flex,\n  Heading,\n  Spacer,\n  Button,\n  Fade,\n} from '@chakra-ui/react'\n// import { Tabs, TabList, TabPanels, Tab, TabPanel } from '@chakra-ui/react'\nimport { CloseIcon, ArrowUpDownIcon } from '@chakra-ui/icons'\n// import MonacoEditor from './Editor'\n\nimport { Itype, Ifunction } from '../interfaces'\nimport { matchSorter } from 'match-sorter'\nimport TypeBadge from '../TypeBadge'\nimport EditableText from '../EditableText'\nimport { Droppable } from 'react-beautiful-dnd'\nimport { Action, NavigationType } from '../../state'\nimport {\n  CompositeDecorator,\n  Editor as DraftEditor,\n  EditorState,\n  ContentState,\n  Entity,\n  Modifier,\n} from 'draft-js'\nimport 'draft-js/dist/Draft.css'\nimport './draftEditorStyles.css'\nimport AutocompleteInput from '../autocomplete-react-draft/src/index'\n// import SuggestionList from './autocomplete-react-draft/src/suggestions'\nimport { getDefaultKeyBinding, KeyBindingUtil } from 'draft-js'\nimport {\n  ClearButton,\n  DocsExplanation,\n  DocsNavigationArrows,\n  DocsNavigationTypeSelector,\n  SaveButton,\n  TypeSuggestionList,\n} from './components'\nconst { hasCommandModifier } = KeyBindingUtil\n\nconst { useCallback } = React\n\nconst autocompleteKeyBindingFn = (e: any): string | null => {\n  //TODO e type\n  switch (e.key) {\n    case 'ArrowDown':\n      return 'down'\n    case 'ArrowUp':\n      return 'up'\n    case 'Escape':\n      return 'close'\n    case 'Enter':\n      return 'select'\n    case 'Tab':\n      return 'select'\n    default:\n      return getDefaultKeyBinding(e)\n  }\n}\n\nconst defaultName = 'name'\n// const defaultType = '_'\nconst typeSuggestions: Array<{ title: Itype['type'] /*| 'New type' */ }> = [\n  { title: 'string' },\n  { title: 'boolean' },\n  { title: 'number' },\n]\n\nconst safeEval = (s: string) => {\n  try {\n    return eval(`(() => ${s})()`)\n  } catch (error) {\n    return null\n  }\n}\nconst getParamsAndReturns = (s: string) =>\n  s.split(arrow).map(s => ({ type: s.trim() }))\n\nconst isSignatureCorrect = (\n  paramsAndReturns: Array<{ type: string }>,\n): paramsAndReturns is Array<Itype> =>\n  paramsAndReturns.length > 1 &&\n  paramsAndReturns.every(p => ['boolean', 'number', 'string'].includes(p.type))\n\nconst getFilteredTypeSuggestions = (\n  typeSuggestions_: typeof typeSuggestions,\n  inputValue?: string,\n) => {\n  if (inputValue === undefined || inputValue === null) return []\n  if (inputValue === '' || inputValue === ' ') return typeSuggestions\n  if (typeSuggestions.some(s => s.title === inputValue)) return []\n  return matchSorter(typeSuggestions_, inputValue, { keys: ['title'] })\n}\n\nconst getFilteredFunctions = (functions: Ifunction[], inputValue?: string) => {\n  if (inputValue === undefined || inputValue === null) return []\n  if (inputValue === '') return functions\n  return matchSorter(functions, inputValue, { keys: ['name'] })\n}\n\nconst arrow = '->'\n\nconst typeToName = (x: { type: string }, n: number): string => {\n  const suffix = n || ''\n  switch (x.type) {\n    case 'string':\n      return 'str' + suffix\n    case 'number':\n      return 'num' + suffix\n    case 'boolean':\n      return 'bool' + suffix\n    default:\n      return 'x'\n    // case 'function':\n    //   return ['f', 'g', 'h', 'i', 'j'][n]\n    // case 'object':\n    //   return 'o' + suffix\n\n    // case 'array':\n    //   return '' //TODO\n    // case 'undefined':\n    // case 'null':\n    //   return ''\n  }\n}\nconst getParamNames = (arr: Array<{ type: string }>): string[] => {\n  let result: string[] = []\n  let alreadySeenTypes: any = {}\n  arr.forEach(iType => {\n    const paramName = typeToName(iType, alreadySeenTypes[iType.type])\n    result.push(paramName)\n    alreadySeenTypes[iType.type] = (alreadySeenTypes[iType.type] || 0) + 1\n  })\n  return result\n}\n\nfunction findWithRegex(regex: any, contentBlock: any, callback: any) {\n  const text = contentBlock.getText()\n  let matchArr, start\n  while ((matchArr = regex.exec(text)) !== null) {\n    start = matchArr.index\n    callback(start, start + matchArr[0].length)\n  }\n}\n\nconst signatureDecorator = new CompositeDecorator([\n  {\n    //TypeBadge\n    strategy(contentBlock, cb, contentState) {\n      findWithRegex(\n        new RegExp(\n          `(${typeSuggestions.map(({ title }) => title).join('|')})`,\n          'gi',\n        ),\n        contentBlock,\n        cb,\n      )\n    },\n    component(props: any) {\n      return (\n        <TypeBadge\n          typeAsString={props.decoratedText}\n          children={props.children}\n          as='span'\n        />\n      )\n    },\n  },\n])\n\nconst HANDLE_REGEX = /@[\\w]+/g\n\nconst getStateValueFromFunc = (\n  descriptionDecorator: CompositeDecorator,\n  func?: Ifunction,\n): {\n  name: string\n  signature: EditorState\n  description: EditorState\n  code: string\n} => {\n  return {\n    name: func?.name || '',\n    signature: EditorState.createWithContent(\n      ContentState.createFromText(\n        func?.parameters\n          .concat(func.returns)\n          .map(p => p.type)\n          .join(` ${arrow} `) || '',\n      ),\n      signatureDecorator,\n    ),\n    description: EditorState.createWithContent(\n      ContentState.createFromText(func?.description || ''),\n      descriptionDecorator,\n    ),\n    code: func?.fn.toString() || '',\n  }\n}\n\ntype DocsCardState = {\n  name: string\n  signature: EditorState\n  description: EditorState\n  code: string\n}\n\nconst setOriginalState = (\n  originalState: React.MutableRefObject<{\n    name: string\n    signatureString: string\n    descriptionString: string\n    code: string\n  }>,\n  state: DocsCardState,\n) => {\n  const newOriginalState = {\n    name: state.name,\n    signatureString: state.signature.getCurrentContent().getPlainText(),\n    descriptionString: state.description.getCurrentContent().getPlainText(),\n    code: state.code,\n  }\n\n  originalState.current = newOriginalState\n}\n\n/**\n *\n *\n * DOCS CARD\n *\n *\n */\n\nconst DocsCard = ({\n  func,\n  dispatch,\n  index,\n  functions,\n  navigationType,\n}: {\n  func?: Ifunction\n  dispatch: React.Dispatch<Action>\n  index: number\n  functions: Ifunction[]\n  navigationType?: NavigationType\n}) => {\n  const descriptionDecorator = new CompositeDecorator([\n    {\n      //TypeBadge\n      strategy(contentBlock, cb, contentState) {\n        findWithRegex(HANDLE_REGEX, contentBlock, cb)\n      },\n      component(props: any) {\n        return (\n          <Button\n            as='span'\n            variant='link'\n            color='unison.aqua'\n            fontSize='inherit'\n            fontStyle='inherit'\n            style={{\n              direction: 'ltr',\n              unicodeBidi: 'bidi-override',\n            }}\n            data-offset-key={props.offsetKey}\n            onClick={e => {\n              dispatch({\n                type: 'openDocs',\n                fnName: props.decoratedText.slice(1),\n              })\n            }}\n          >\n            {props.children}\n          </Button>\n        )\n      },\n    },\n  ])\n  const originalState = React.useRef<{\n    name: string\n    signatureString: string\n    descriptionString: string\n    code: string\n  }>({\n    name: '',\n    signatureString: '',\n    descriptionString: '',\n    code: '',\n  })\n  const [state, setState] = React.useState<DocsCardState>(() => {\n    const state = getStateValueFromFunc(descriptionDecorator, func)\n    setOriginalState(originalState, state)\n    return state\n  })\n\n  const [previousFunc, setPreviousFunc] = React.useState(func)\n  if (previousFunc !== func) {\n    //reference check on function from state.functions\n    setPreviousFunc(func)\n    const state = getStateValueFromFunc(descriptionDecorator, func)\n    setOriginalState(originalState, state)\n    setState(state)\n  }\n  const { name, signature, description, code } = state\n\n  /* Name */\n  const onChangeName = (name: string) => setState(state => ({ ...state, name }))\n  const nameFontStyle = [defaultName, ''].includes(name) ? 'italic' : 'normal'\n  const nameColor = [defaultName, ''].includes(name) ? 'gray.400' : 'normal'\n\n  /* Description */\n  const onChangeDescription = (description: EditorState) =>\n    setState(state => ({ ...state, description }))\n  const descriptionHasText = description.getCurrentContent().hasText()\n  const descriptionFontStyle = descriptionHasText ? 'normal' : 'italic'\n  const descriptionColor = descriptionHasText ? 'normal' : 'gray.400'\n  // const descriptionEditorRef = React.useRef(null)\n  const [\n    autocompleteDescription,\n    setAutocompleteDescription,\n  ] = React.useState<any>(null)\n  const filteredFunctions = getFilteredFunctions(\n    functions,\n    autocompleteDescription?.text,\n  )\n\n  /* Signature */\n\n  // const [signatureEditorState, setSignatureEditorState] = React.useState(() =>\n  //   EditorState.createEmpty(signatureDecorator),\n  // )\n  const signatureEditorRef = React.useRef<DraftEditor>(null)\n  const signatureEditorParentRef = React.useRef<HTMLElement>(null)\n  const coordsSignatureEditor = React.useRef<any>(null)\n\n  const onChangeSignatureEditor = (e: EditorState) => {\n    let newEditorState: EditorState\n    switch (e.getLastChangeType()) {\n      case 'insert-characters':\n        const text = e.getCurrentContent().getFirstBlock().getText()\n        let newText = text\n        const triggerArrow = text.endsWith(',') || text.endsWith(' ')\n        if (triggerArrow) {\n          //TODO arrow component\n          const previousMeaningfulCharIsArrow = text\n            .replace(',', ' ')\n            .trimEnd()\n            .endsWith(arrow)\n          const previousCharIsClosingBracket = text\n            .substr(0, text.length - 1)\n            .endsWith('}')\n          if (previousMeaningfulCharIsArrow) {\n            newText = text //.substr(0, text.length - 1)\n          } else if (previousCharIsClosingBracket && text.endsWith(' ')) {\n            //abilities\n            newText = text\n          } else {\n            // only if last non-space or comma char is not arrow\n            newText = text.substr(0, text.length - 1).concat(` ${arrow} `)\n          }\n        }\n\n        newEditorState =\n          text === newText\n            ? e\n            : EditorState.moveFocusToEnd(\n                EditorState.push(\n                  e,\n                  ContentState.createFromText(newText),\n                  'insert-fragment',\n                ),\n              )\n        break\n      default:\n        newEditorState = e\n        break\n    }\n    setState(state => ({ ...state, signature: newEditorState }))\n\n    /* autocomplete */\n\n    window.requestAnimationFrame(() => {\n      const selection = window.getSelection() as Selection\n      if (selection.rangeCount === 0) {\n        //focus is outside\n        setAutocompleteState(null)\n        return\n      }\n      const stateSelection = newEditorState.getSelection()\n      // const contentState = newEditorState.getCurrentContent()\n      // const block = contentState.getBlockForKey(stateSelection.getStartKey())\n      if (\n        !stateSelection.getHasFocus() /*||\n        block.getEntityAt(stateSelection.getStartOffset() - 1*/\n      ) {\n        setAutocompleteState(null)\n        return\n      }\n      const range = selection.getRangeAt(0)\n      // let text = range.startContainer.textContent//!.substring(\n      //b|oolean -> 'b\n      //0,\n      //range.startOffset,\n      //)\n      // console.log(1, { text, stateSelection })\n      const wholeWordText = range.startContainer.textContent as string //b|oolean -> 'boolean'\n      let index = wholeWordText.length > 0 ? wholeWordText.lastIndexOf(' ') : 0\n      index = index === -1 ? 0 : index\n      const text = wholeWordText.substring(index).trim()\n\n      // console.log(3, { text })\n\n      let { left } = range.getBoundingClientRect()\n      const editorParent = signatureEditorParentRef.current as HTMLElement\n      const coords =\n        coordsSignatureEditor.current ?? editorParent.getBoundingClientRect()\n      coordsSignatureEditor.current = coords //TODO reset this cache\n      let top = coords.bottom\n      if (left === 0) {\n        left = coords.left\n      }\n\n      setAutocompleteState({\n        left,\n        top,\n        text,\n        wholeWordText,\n        startIndex: index,\n        selectedIndex: 0,\n      })\n    })\n  }\n  const handleKeyCommand = (command: 'up' | 'down' | 'close' | 'select') => {\n    switch (command) {\n      case 'up': {\n        setAutocompleteState((state: any) => ({\n          ...state,\n          selectedIndex:\n            state.selectedIndex === 0 ? 0 : state.selectedIndex - 1,\n        }))\n        return 'handled'\n      }\n      case 'down': {\n        setAutocompleteState((state: any) => ({\n          ...state,\n          selectedIndex:\n            state.selectedIndex === filteredSuggestions.length - 1\n              ? filteredSuggestions.length - 1\n              : state.selectedIndex + 1,\n        }))\n        return 'handled'\n      }\n      case 'close': {\n        signatureEditorRef.current!.blur()\n        return 'handled'\n      }\n      case 'select': {\n        const currentSelectionState = signature.getSelection()\n        const anchorOffset /*end */ = currentSelectionState.getAnchorOffset()\n        const anchorKey = currentSelectionState.getAnchorKey()\n        const currentContent = signature.getCurrentContent()\n        const currentBlock = currentContent.getBlockForKey(anchorKey)\n        const blockText = currentBlock.getText()\n        console.log({\n          blockText,\n          signatureString,\n          text: autocompleteState.text,\n          wholeWordText: autocompleteState.wholeWordText,\n          anchorOffset,\n          anchorKey,\n        })\n        // const start = blockText.substring(0, end).lastIndexOf(trigger)\n        // return {\n        // editorState,\n        // start,\n        // end,\n        // trigger,\n        // selectedIndex: autocompleteState.selectedIndex,\n        // }\n\n        // add suggestion\n        const textToInsert =\n          filteredSuggestions[autocompleteState.selectedIndex].title\n        const newCurrentContent = currentContent.createEntity(\n          'TYPE',\n          'IMMUTABLE',\n        )\n        const entityKey = newCurrentContent.getLastCreatedEntityKey()\n        const mentionTextSelection = currentSelectionState.merge({\n          anchorOffset: autocompleteState.startIndex,\n          focusOffset: anchorOffset,\n        })\n        let insertingContent = Modifier.replaceText(\n          signature.getCurrentContent(),\n          mentionTextSelection,\n          textToInsert,\n          undefined,\n          // ['link', 'BOLD'],\n          entityKey,\n        )\n        const newEditorState = EditorState.push(\n          signature,\n          insertingContent,\n          'apply-entity',\n        )\n        setState(state => ({ ...state, signature: newEditorState }))\n\n        // EditorState.forceSelection(\n        //   newEditorState,\n        //   insertingContent.getSelectionAfter(),\n        // ),\n\n        return 'handled'\n      }\n      default:\n        return 'not-handled'\n    }\n  }\n\n  const [autocompleteState, setAutocompleteState] = React.useState<any>(null)\n  const filteredSuggestions = getFilteredTypeSuggestions(\n    typeSuggestions,\n    autocompleteState?.text,\n  )\n\n  /* Code */\n\n  const onChangeCode = (code: string) => setState(state => ({ ...state, code }))\n  const signatureString = signature.getCurrentContent().getPlainText()\n  const paramsAndReturns = getParamsAndReturns(signatureString)\n  const params = paramsAndReturns.slice(0, paramsAndReturns.length - 1)\n  const paramNames = getParamNames(params)\n  const editorValue =\n    code || `function ${name || 'name'}(${paramNames.join(', ')}) {\\n\\n}`\n\n  // const [signatureTouched, setSignatureTouched] = React.useState<boolean>(false)\n  const signatureError = !isSignatureCorrect(paramsAndReturns)\n\n  const hasChanges =\n    name !== originalState.current.name ||\n    signatureString !== originalState.current.signatureString ||\n    description.getCurrentContent().getPlainText() !==\n      originalState.current.descriptionString ||\n    code !== originalState.current.code\n\n  const onSaveButtonClick = () => {\n    const fn = safeEval(code)\n    const validParams = isSignatureCorrect(paramsAndReturns)\n    if (!fn || !validParams) {\n      return //TODO alert\n    }\n    const parameters = paramsAndReturns.slice(\n      0,\n      paramsAndReturns.length - 1,\n    ) as Itype[] //TODO cast\n    const returns = paramsAndReturns.slice(-1).pop() as Itype\n    dispatch({\n      type: 'createFunction',\n      function: {\n        name,\n        parameters,\n        returns,\n        fn,\n        description: description.getCurrentContent().getPlainText(),\n      },\n      index,\n    })\n  }\n\n  const onClearButtonClick = useCallback(() => {\n    const state = getStateValueFromFunc(descriptionDecorator, undefined)\n    setOriginalState(originalState, state)\n    setState(state)\n    dispatch({ type: 'clearDocsCard', index })\n  }, [originalState, index])\n\n  return (\n    <Box\n      boxShadow={'base'}\n      // minWidth={'48%'} //@TODO prevent Yscroll another way\n      // minHeight='100%'\n      backgroundColor='white'\n      padding={1}\n      minWidth={'50%'}\n      minHeight='100vh'\n      height='100%'\n      // position='relative'\n      display='flex'\n      flexDirection='column'\n    >\n      <Code\n        // SIGNATURE EDITOR\n        fontSize='sm'\n        width='100%'\n        paddingX={1}\n        paddingY={1}\n        as='span'\n        ref={signatureEditorParentRef}\n        // position='relative'\n      >\n        <DraftEditor\n          editorState={signature}\n          ref={signatureEditorRef}\n          onChange={onChangeSignatureEditor}\n          keyBindingFn={autocompleteKeyBindingFn}\n          handleKeyCommand={handleKeyCommand}\n\n          // onBlur={(e: any) => {\n          //   setSignatureTouched(true)\n          // }}\n        />\n        {filteredSuggestions.length > 0 ? (\n          <TypeSuggestionList\n            typeSuggestions={filteredSuggestions}\n            selectedIndex={autocompleteState.selectedIndex}\n            left={autocompleteState.left}\n            top={autocompleteState.top}\n          ></TypeSuggestionList>\n        ) : null}\n      </Code>\n\n      <Flex paddingLeft={2} alignItems='center'>\n        <Heading fontSize='xl' fontStyle='italic' color='unison.purple'>\n          Docs\n        </Heading>\n        {navigationType === 'history' ? (\n          <DocsNavigationArrows\n            dispatch={dispatch}\n            index={}\n          ></DocsNavigationArrows>\n        ) : null}\n        <Spacer></Spacer>\n        <ClearButton\n          onClick={onClearButtonClick}\n          fadeIn={hasChanges}\n        ></ClearButton>\n        <SaveButton\n          onClick={onSaveButtonClick}\n          fadeIn={hasChanges}\n          disabled={signatureError}\n        ></SaveButton>\n        <DocsExplanation />\n        {navigationType ? (\n          <DocsNavigationTypeSelector\n            dispatch={dispatch}\n            navigationType={navigationType}\n          ></DocsNavigationTypeSelector>\n        ) : null}\n        <IconButton //Close Button\n          aria-label='Close card'\n          icon={<CloseIcon />}\n          variant='ghost'\n          size='sm'\n          onClick={() => dispatch({ type: 'closeDocsCard', index })}\n        />\n      </Flex>\n      <Divider marginTop={2}></Divider>\n      <Droppable droppableId='DocsCard'>\n        {(provided, snapshot) => {\n          return (\n            <Box\n              ref={provided.innerRef}\n              {...provided.droppableProps}\n              // minWidth={'50%'}\n              flex={1}\n              minHeight='100%'\n              height='100%'\n              overflow='auto'\n              paddingX={2}\n              paddingY={2}\n            >\n              <EditableText\n                /* NAME */\n                value={name}\n                onChange={onChangeName}\n                placeholder={defaultName}\n                fontSize='2xl'\n                textColor={nameColor}\n                fontStyle={nameFontStyle}\n                marginBottom={3}\n              />\n\n              {/* SIGNATURE */}\n              <HStack>\n                <Code fontSize='sm' padding={0.5}>\n                  <Editable\n                    as='span'\n                    placeholder={defaultName}\n                    fontStyle={nameFontStyle}\n                    // width={name.length * 12 + 12 + 'px'}\n                    width={(name.length > 3 ? name.length : 4) * 9 + 9 + 'px'}\n                    // minWidth={(name || defaultName).length * 12 + 12 + 'px'}\n                    value={name}\n                    textColor={nameColor}\n                    onChange={onChangeName}\n                    paddingX={1}\n                  >\n                    <EditablePreview\n                      width={(name.length > 3 ? name.length : 4) * 9 + 9 + 'px'}\n                    />\n                    <EditableInput\n                      width={(name.length > 3 ? name.length : 4) * 9 + 9 + 'px'}\n                      _focus={{\n                        outline: '',\n                      }}\n                    />\n                  </Editable>\n                </Code>\n\n                <Text as='span' fontSize='sm'>\n                  :{' '}\n                </Text>\n                <Code\n                  // SIGNATURE EDITOR\n                  fontSize='sm'\n                  width='100%'\n                  paddingX={1}\n                  paddingY={1}\n                  as='span'\n                >\n                  {/* <DraftEditor\n                    editorState={signature}\n                    ref={signatureEditorRef}\n                    onChange={onChangeSignatureEditor}\n                    // onBlur={(e: any) => {\n                    //   setSignatureTouched(true)\n                    // }}\n                  /> */}\n                </Code>\n              </HStack>\n\n              <Text\n                /* DESCRIPTION */\n                className='description'\n                marginTop={5}\n                fontSize='xl'\n                fontStyle={descriptionFontStyle}\n                color={descriptionColor}\n                backgroundColor='yellow.50'\n                padding={3}\n              >\n                <DraftEditor\n                  placeholder='Description'\n                  editorState={description}\n                  onChange={onChangeDescription}\n                ></DraftEditor>\n              </Text>\n              {/* <Tabs marginTop={5}>\n                <TabList>\n                  <Tab>Regular editor</Tab>\n                  <Tab>Structured editor</Tab>\n                </TabList>\n                <TabPanels>\n                  <TabPanel> */}\n              {/* <Box marginTop={5}>\n                <MonacoEditor\n                  value={editorValue}\n                  onChange={(_, v: any) => {\n                    onChangeCode(v)\n                  }}\n                ></MonacoEditor>\n              </Box> */}\n\n              {/* </TabPanel>\n                  <TabPanel>\n                    <Code>{editorValue}</Code>\n                  </TabPanel>\n                </TabPanels>\n              </Tabs> */}\n              <AutocompleteInput></AutocompleteInput>\n\n              {provided.placeholder}\n            </Box>\n          )\n        }}\n      </Droppable>\n    </Box>\n  )\n}\nexport default DocsCard\n",{"ruleId":"188","severity":1,"message":"189","line":3,"column":27,"nodeType":"190","messageId":"191","endLine":3,"endColumn":38},{"ruleId":"192","replacedBy":"193"},{"ruleId":"194","replacedBy":"195"},{"ruleId":"192","replacedBy":"196"},{"ruleId":"194","replacedBy":"197"},{"ruleId":"192","replacedBy":"198"},{"ruleId":"194","replacedBy":"199"},{"ruleId":"188","severity":1,"message":"200","line":17,"column":3,"nodeType":"190","messageId":"191","endLine":17,"endColumn":20},{"ruleId":"188","severity":1,"message":"201","line":18,"column":3,"nodeType":"190","messageId":"191","endLine":18,"endColumn":18},{"ruleId":"188","severity":1,"message":"202","line":422,"column":31,"nodeType":"190","messageId":"191","endLine":422,"endColumn":39},{"ruleId":"188","severity":1,"message":"203","line":8,"column":3,"nodeType":"190","messageId":"191","endLine":8,"endColumn":11},{"ruleId":"188","severity":1,"message":"204","line":2,"column":27,"nodeType":"190","messageId":"191","endLine":2,"endColumn":36},{"ruleId":"188","severity":1,"message":"203","line":2,"column":38,"nodeType":"190","messageId":"191","endLine":2,"endColumn":46},{"ruleId":"188","severity":1,"message":"205","line":7,"column":3,"nodeType":"190","messageId":"191","endLine":7,"endColumn":9},{"ruleId":"188","severity":1,"message":"206","line":18,"column":3,"nodeType":"190","messageId":"191","endLine":18,"endColumn":21},{"ruleId":"188","severity":1,"message":"207","line":19,"column":3,"nodeType":"190","messageId":"191","endLine":19,"endColumn":25},{"ruleId":"188","severity":1,"message":"208","line":20,"column":3,"nodeType":"190","messageId":"191","endLine":20,"endColumn":25},{"ruleId":"188","severity":1,"message":"209","line":22,"column":3,"nodeType":"190","messageId":"191","endLine":22,"endColumn":7},{"ruleId":"188","severity":1,"message":"210","line":32,"column":3,"nodeType":"190","messageId":"191","endLine":32,"endColumn":17},{"ruleId":"188","severity":1,"message":"211","line":196,"column":34,"nodeType":"190","messageId":"191","endLine":196,"endColumn":36},{"ruleId":"212","severity":1,"message":"213","line":290,"column":25,"nodeType":"214","endLine":294,"endColumn":27},{"ruleId":"212","severity":1,"message":"213","line":305,"column":17,"nodeType":"214","endLine":310,"endColumn":19},{"ruleId":"212","severity":1,"message":"213","line":313,"column":15,"nodeType":"214","endLine":318,"endColumn":17},{"ruleId":"188","severity":1,"message":"215","line":1,"column":8,"nodeType":"190","messageId":"191","endLine":1,"endColumn":15},{"ruleId":"188","severity":1,"message":"216","line":5,"column":8,"nodeType":"190","messageId":"191","endLine":5,"endColumn":16},{"ruleId":"188","severity":1,"message":"217","line":1,"column":24,"nodeType":"190","messageId":"191","endLine":1,"endColumn":43},{"ruleId":"192","replacedBy":"218"},{"ruleId":"194","replacedBy":"219"},{"ruleId":"220","severity":1,"message":"221","line":1,"column":10,"nodeType":"190","messageId":"191","endLine":1,"endColumn":16},{"ruleId":"220","severity":1,"message":"222","line":1,"column":18,"nodeType":"190","messageId":"191","endLine":1,"endColumn":26},{"ruleId":"220","severity":1,"message":"223","line":1,"column":28,"nodeType":"190","messageId":"191","endLine":1,"endColumn":34},{"ruleId":"220","severity":1,"message":"224","line":46,"column":32,"nodeType":"190","messageId":"191","endLine":46,"endColumn":49},{"ruleId":"225","severity":1,"message":"226","line":60,"column":28,"nodeType":"227","messageId":"228","endLine":60,"endColumn":30},{"ruleId":"192","replacedBy":"229"},{"ruleId":"194","replacedBy":"230"},{"ruleId":"220","severity":1,"message":"231","line":1,"column":10,"nodeType":"190","messageId":"191","endLine":1,"endColumn":16},{"ruleId":"220","severity":1,"message":"232","line":3,"column":18,"nodeType":"190","messageId":"191","endLine":3,"endColumn":29},{"ruleId":"220","severity":1,"message":"233","line":42,"column":13,"nodeType":"190","messageId":"191","endLine":42,"endColumn":25},{"ruleId":"220","severity":1,"message":"234","line":94,"column":13,"nodeType":"190","messageId":"191","endLine":94,"endColumn":24},{"ruleId":"235","severity":1,"message":"236","line":216,"column":3,"nodeType":"237","messageId":"228","endLine":266,"endColumn":4},{"ruleId":"235","severity":1,"message":"238","line":268,"column":3,"nodeType":"237","messageId":"228","endLine":289,"endColumn":4},{"ruleId":"235","severity":1,"message":"239","line":291,"column":3,"nodeType":"237","messageId":"228","endLine":301,"endColumn":4},{"ruleId":"220","severity":1,"message":"240","line":306,"column":7,"nodeType":"190","messageId":"191","endLine":306,"endColumn":15},{"ruleId":"220","severity":1,"message":"241","line":308,"column":7,"nodeType":"190","messageId":"191","endLine":308,"endColumn":15},{"ruleId":"220","severity":1,"message":"242","line":309,"column":7,"nodeType":"190","messageId":"191","endLine":309,"endColumn":16},{"ruleId":"220","severity":1,"message":"243","line":310,"column":7,"nodeType":"190","messageId":"191","endLine":310,"endColumn":18},{"ruleId":"220","severity":1,"message":"244","line":311,"column":7,"nodeType":"190","messageId":"191","endLine":311,"endColumn":27},{"ruleId":"192","replacedBy":"245"},{"ruleId":"194","replacedBy":"246"},{"ruleId":"225","severity":1,"message":"226","line":14,"column":15,"nodeType":"227","messageId":"228","endLine":14,"endColumn":17},{"ruleId":"225","severity":1,"message":"226","line":18,"column":15,"nodeType":"227","messageId":"228","endLine":18,"endColumn":17},{"ruleId":"192","replacedBy":"247"},{"ruleId":"194","replacedBy":"248"},{"ruleId":"192","replacedBy":"249"},{"ruleId":"194","replacedBy":"250"},{"ruleId":"220","severity":1,"message":"223","line":1,"column":28,"nodeType":"190","messageId":"191","endLine":1,"endColumn":34},{"ruleId":"220","severity":1,"message":"231","line":2,"column":10,"nodeType":"190","messageId":"191","endLine":2,"endColumn":16},{"ruleId":"188","severity":1,"message":"251","line":2,"column":29,"nodeType":"190","messageId":"191","endLine":2,"endColumn":35},{"ruleId":"188","severity":1,"message":"252","line":8,"column":3,"nodeType":"190","messageId":"191","endLine":8,"endColumn":12},{"ruleId":"188","severity":1,"message":"253","line":14,"column":10,"nodeType":"190","messageId":"191","endLine":14,"endColumn":22},{"ruleId":"188","severity":1,"message":"254","line":16,"column":3,"nodeType":"190","messageId":"191","endLine":16,"endColumn":7},{"ruleId":"188","severity":1,"message":"255","line":19,"column":21,"nodeType":"190","messageId":"191","endLine":19,"endColumn":36},{"ruleId":"188","severity":1,"message":"221","line":33,"column":3,"nodeType":"190","messageId":"191","endLine":33,"endColumn":9},{"ruleId":"188","severity":1,"message":"256","line":49,"column":9,"nodeType":"190","messageId":"191","endLine":49,"endColumn":27},{"ruleId":"257","severity":1,"message":"258","line":81,"column":12,"nodeType":"259","messageId":"228","endLine":81,"endColumn":16},{"ruleId":"188","severity":1,"message":"260","line":331,"column":5,"nodeType":"190","messageId":"191","endLine":331,"endColumn":31},{"ruleId":"188","severity":1,"message":"261","line":333,"column":9,"nodeType":"190","messageId":"191","endLine":333,"endColumn":26},{"ruleId":"188","severity":1,"message":"262","line":539,"column":9,"nodeType":"190","messageId":"191","endLine":539,"endColumn":21},{"ruleId":"188","severity":1,"message":"263","line":544,"column":9,"nodeType":"190","messageId":"191","endLine":544,"endColumn":20},{"ruleId":"264","severity":1,"message":"265","line":586,"column":6,"nodeType":"266","endLine":586,"endColumn":28,"suggestions":"267"},"@typescript-eslint/no-unused-vars","'extendTheme' is defined but never used.","Identifier","unusedVar","no-native-reassign",["268"],"no-negated-in-lhs",["269"],["268"],["269"],["268"],["269"],"'InputRightElement' is defined but never used.","'InputRightAddon' is defined but never used.","'_' is assigned a value but never used.","'useTheme' is defined but never used.","'TextProps' is defined but never used.","'Center' is defined but never used.","'NumberInputStepper' is defined but never used.","'NumberIncrementStepper' is defined but never used.","'NumberDecrementStepper' is defined but never used.","'Text' is defined but never used.","'PlusSquareIcon' is defined but never used.","'id' is assigned a value but never used.","react/jsx-pascal-case","Imported JSX component C_TypeAndValue must be in PascalCase or SCREAMING_SNAKE_CASE","JSXOpeningElement","'produce' is defined but never used.","'DocsCard' is defined but never used.","'QuestionOutlineIcon' is defined but never used.",["268"],["269"],"no-unused-vars","'Entity' is defined but never used.","'Modifier' is defined but never used.","'Editor' is defined but never used.","'onSuggestionClick' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected",["268"],["269"],"'render' is defined but never used.","'EditorState' is defined but never used.","'contentState' is assigned a value but never used.","'editorState' is assigned a value but never used.","no-dupe-class-members","Duplicate name 'getAutocompleteState'.","MethodDefinition","Duplicate name 'getAutocompleteRange'.","Duplicate name 'hasEntityAtSelection'.","'onChange' is assigned a value but never used.","'onEscape' is assigned a value but never used.","'onUpArrow' is assigned a value but never used.","'onDownArrow' is assigned a value but never used.","'onAutocompleteChange' is assigned a value but never used.",["268"],["269"],["268"],["269"],["268"],["269"],"'Switch' is defined but never used.","'CloseIcon' is defined but never used.","'FunctionItem' is defined but never used.","'Fade' is defined but never used.","'ArrowUpDownIcon' is defined but never used.","'hasCommandModifier' is assigned a value but never used.","no-eval","eval can be harmful.","CallExpression","'setAutocompleteDescription' is assigned a value but never used.","'filteredFunctions' is assigned a value but never used.","'onChangeCode' is assigned a value but never used.","'editorValue' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useCallback has missing dependencies: 'descriptionDecorator' and 'dispatch'. Either include them or remove the dependency array. If 'dispatch' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["270"],"no-global-assign","no-unsafe-negation",{"desc":"271","fix":"272"},"Update the dependencies array to be: [descriptionDecorator, dispatch, index]",{"range":"273","text":"274"},[16807,16829],"[descriptionDecorator, dispatch, index]"]