{"version":3,"sources":["components/DocsCard/DocsCard.tsx","components/Editor.tsx","components/EditableText.tsx","components/Sidebar.tsx","components/CardHStack.tsx","components/FlowCard.tsx","App.tsx","reportWebVitals.ts","serviceWorker.ts","theme.ts","index.tsx","components/TypeBadge.tsx","components/DocsCard/components.tsx","components/PopoverExplanation.tsx","state.ts"],"names":["hasCommandModifier","KeyBindingUtil","useCallback","React","autocompleteKeyBindingFn","e","key","getDefaultKeyBinding","defaultName","typeSuggestions","title","safeEval","s","eval","error","getParamsAndReturns","split","arrow","map","type","trim","isSignatureCorrect","paramsAndReturns","length","every","p","includes","getFilteredTypeSuggestions","typeSuggestions_","inputValue","undefined","some","matchSorter","keys","getFilteredFunctions","functions","typeToName","x","n","suffix","getParamNames","arr","result","alreadySeenTypes","forEach","iType","paramName","push","findWithRegex","regex","contentBlock","callback","matchArr","start","text","getText","exec","index","signatureDecorator","CompositeDecorator","strategy","cb","contentState","RegExp","join","component","props","typeAsString","decoratedText","children","as","HANDLE_REGEX","getStateValueFromFunc","descriptionDecorator","func","name","signature","EditorState","createWithContent","ContentState","createFromText","parameters","concat","returns","description","code","fn","toString","setOriginalState","originalState","state","newOriginalState","signatureString","getCurrentContent","getPlainText","descriptionString","current","DocsCard","dispatch","navigationType","variant","color","fontSize","fontStyle","style","direction","unicodeBidi","data-offset-key","offsetKey","onClick","openerIndex","fnName","slice","setState","previousFunc","setPreviousFunc","onChangeName","nameFontStyle","nameColor","onChangeDescription","descriptionHasText","hasText","descriptionFontStyle","descriptionColor","autocompleteDescription","signatureEditorRef","signatureEditorParentRef","coordsSignatureEditor","onChangeSignatureEditor","newEditorState","getLastChangeType","getFirstBlock","newText","endsWith","previousMeaningfulCharIsArrow","replace","trimEnd","previousCharIsClosingBracket","substr","moveFocusToEnd","window","requestAnimationFrame","selection","getSelection","rangeCount","getHasFocus","range","getRangeAt","wholeWordText","startContainer","textContent","lastIndexOf","substring","left","getBoundingClientRect","editorParent","coords","top","bottom","setAutocompleteState","startIndex","selectedIndex","handleKeyCommand","command","filteredSuggestions","blur","currentSelectionState","anchorOffset","getAnchorOffset","anchorKey","getAnchorKey","currentContent","blockText","getBlockForKey","console","log","autocompleteState","textToInsert","entityKey","createEntity","getLastCreatedEntityKey","mentionTextSelection","merge","focusOffset","insertingContent","Modifier","replaceText","params","paramNames","editorValue","signatureError","hasChanges","onClearButtonClick","boxShadow","backgroundColor","padding","minWidth","minHeight","height","display","flexDirection","paddingLeft","alignItems","fadeIn","validParams","pop","function","disabled","aria-label","icon","size","marginTop","droppableId","provided","snapshot","ref","innerRef","droppableProps","flex","overflow","paddingX","paddingY","value","onChange","placeholder","textColor","marginBottom","width","_focus","outline","editorState","keyBindingFn","className","_","v","onChangeCode","Editor","language","theme","options","minimap","enabled","lineNumbers","EditableText","forwardRef","FunctionItem","wrap","_hover","rounded","flexWrap","i","TypeBadge","ArrowForward","marginX","getFunctionRenderItem","rubric","draggableProps","dragHandleProps","useTreeItemStyles","makeStyles","root","content","cursor","FunctionTreeItem","TreeItem","classes","isAnyItemDragging","nodeId","label","renderClone","isDropDisabled","shouldRenderClone","draggingFromThisWith","draggableId","TypeTreeItem","Sidebar","items","searchValue","useTheme","colors","unison","purple","lightPurple","aqua","isHoveringSearch","setIsHoveringSearch","isFocusedSearch","setFocusedSearch","onMouseEnterSearch","onMouseLeaveSearch","paddingTop","whiteSpace","onMouseEnter","onMouseLeave","pointerEvents","Search","borderBottomColor","focusBorderColor","borderRadius","borderTop","borderLeft","borderRight","borderBottom","onFocus","setSelectionRange","onBlur","target","background","position","right","PopoverExplanation","TreeView","selected","defaultCollapseIcon","ChevronDown","defaultExpandIcon","ChevronRight","onNodeFocus","draggable","document","querySelector","querySelectorAll","classList","remove","div","parentElement","li","parentMenu","previous","previousElementSibling","next","nextElementSibling","bound","MouseTrap","bind","focus","add","item","fontWeight","innerItem","id","CardHStack","overflowX","TypeAndValue","justifyContent","isNaN","Number","allowMouseWheel","isChecked","checked","C_TypeAndValue","fnId","paramIndex","noInput","ParameterContext","fns","setFns","find","param","findIndex","previousFns","affectedFns","newValues","previousReturn","newItems","previouslastParam","returnValue","getParamValues","FlowFunctionView","isFirstFunctionInFlow","rest","hasZeroParams","hasOneParam","templateColumns","gap","justifySelf","css","transform","ArrowDown","getFnsValuesFromItems","previousItems","pi","err","FlowFunctionsList","setPreviousItems","previousValues","Provider","in","FlowCard","sx","leftIcon","Delete","App","useAppReducer","onDragEnd","dropResult","source","destination","sourceIndex","destinationIndex","sideBarRef","useToken","keyMap","focusSidebar","handlers","onDragStart","defaultSize","minSize","maxSize","pane2Style","isSideBarItemDragging","dataTypes","effects","flowCardFunctions","docCards","docCardsNavigationType","docCardsSelectedIndex","doc","f","Add","colorScheme","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","Boolean","location","hostname","match","extendTheme","styles","global","html","number","bool","shadows","limegreen","green","yellow","orange","pink","lightblue","blue","darkblue","gray","darkOrange","darkGreen","darkPink","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message","string","boolean","object","array","null","useContext","SaveButton","ClearButton","DocsExplanation","TypeSuggestionList","listStyleType","zIndex","textAlign","DocsNavigationTypeSelector","getButtonStyles","isDisabled","DocsNavigationArrows","StateContext","backDisabled","forwardDisabled","to","w","h","margin","hasArrow","initialState","toUpperCase","y","m","reorder","list","endIndex","listCopy","splice","removed","insert","changeAtIndex","getDefaultValue","findFunction","incrementWithinBounds","decrementPositiveNumber","reducer","action","fnIndex","uuid","d","filter"],"mappings":"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","file":"static/js/main.c703cc38.chunk.js","sourcesContent":["import * as React from 'react'\nimport {\n  HStack,\n  Editable,\n  EditablePreview,\n  EditableInput,\n  Text,\n  Code,\n  IconButton,\n  Box,\n  Divider,\n  Flex,\n  Heading,\n  Spacer,\n  Button,\n  Fade,\n} from '@chakra-ui/react'\n// import { Tabs, TabList, TabPanels, Tab, TabPanel } from '@chakra-ui/react'\nimport { CloseIcon, ArrowUpDownIcon } from '@chakra-ui/icons'\nimport MonacoEditor from '../Editor'\n\nimport { Itype, Ifunction } from '../interfaces'\nimport { matchSorter } from 'match-sorter'\nimport TypeBadge from '../TypeBadge'\nimport EditableText from '../EditableText'\nimport { Droppable } from 'react-beautiful-dnd'\nimport { Action, NavigationType } from '../../state'\nimport {\n  CompositeDecorator,\n  Editor as DraftEditor,\n  EditorState,\n  ContentState,\n  Entity,\n  Modifier,\n} from 'draft-js'\nimport 'draft-js/dist/Draft.css'\nimport './draftEditorStyles.css'\nimport AutocompleteInput from '../autocomplete-react-draft/src/index'\n// import SuggestionList from './autocomplete-react-draft/src/suggestions'\nimport { getDefaultKeyBinding, KeyBindingUtil } from 'draft-js'\nimport {\n  ClearButton,\n  DocsExplanation,\n  DocsNavigationArrows,\n  DocsNavigationTypeSelector,\n  SaveButton,\n  TypeSuggestionList,\n} from './components'\nconst { hasCommandModifier } = KeyBindingUtil\n\nconst { useCallback } = React\n\nconst autocompleteKeyBindingFn = (e: any): string | null => {\n  //TODO e type\n  switch (e.key) {\n    case 'ArrowDown':\n      return 'down'\n    case 'ArrowUp':\n      return 'up'\n    case 'Escape':\n      return 'close'\n    case 'Enter':\n      return 'select'\n    case 'Tab':\n      return 'select'\n    default:\n      return getDefaultKeyBinding(e)\n  }\n}\n\nconst defaultName = 'name'\n// const defaultType = '_'\nconst typeSuggestions: Array<{ title: Itype['type'] /*| 'New type' */ }> = [\n  { title: 'string' },\n  { title: 'boolean' },\n  { title: 'number' },\n]\n\nconst safeEval = (s: string) => {\n  try {\n    return eval(`(() => ${s})()`)\n  } catch (error) {\n    return null\n  }\n}\nconst getParamsAndReturns = (s: string) =>\n  s.split(arrow).map(s => ({ type: s.trim() }))\n\nconst isSignatureCorrect = (\n  paramsAndReturns: Array<{ type: string }>,\n): paramsAndReturns is Array<Itype> =>\n  paramsAndReturns.length > 1 &&\n  paramsAndReturns.every(p => ['boolean', 'number', 'string'].includes(p.type))\n\nconst getFilteredTypeSuggestions = (\n  typeSuggestions_: typeof typeSuggestions,\n  inputValue?: string,\n) => {\n  if (inputValue === undefined || inputValue === null) return []\n  if (inputValue === '' || inputValue === ' ') return typeSuggestions\n  if (typeSuggestions.some(s => s.title === inputValue)) return []\n  return matchSorter(typeSuggestions_, inputValue, { keys: ['title'] })\n}\n\nconst getFilteredFunctions = (functions: Ifunction[], inputValue?: string) => {\n  if (inputValue === undefined || inputValue === null) return []\n  if (inputValue === '') return functions\n  return matchSorter(functions, inputValue, { keys: ['name'] })\n}\n\nconst arrow = '->'\n\nconst typeToName = (x: { type: string }, n: number): string => {\n  const suffix = n || ''\n  switch (x.type) {\n    case 'string':\n      return 'str' + suffix\n    case 'number':\n      return 'num' + suffix\n    case 'boolean':\n      return 'bool' + suffix\n    default:\n      return 'x'\n    // case 'function':\n    //   return ['f', 'g', 'h', 'i', 'j'][n]\n    // case 'object':\n    //   return 'o' + suffix\n\n    // case 'array':\n    //   return '' //TODO\n    // case 'undefined':\n    // case 'null':\n    //   return ''\n  }\n}\nconst getParamNames = (arr: Array<{ type: string }>): string[] => {\n  let result: string[] = []\n  let alreadySeenTypes: any = {}\n  arr.forEach(iType => {\n    const paramName = typeToName(iType, alreadySeenTypes[iType.type])\n    result.push(paramName)\n    alreadySeenTypes[iType.type] = (alreadySeenTypes[iType.type] || 0) + 1\n  })\n  return result\n}\n\nfunction findWithRegex(regex: any, contentBlock: any, callback: any) {\n  const text = contentBlock.getText()\n  let matchArr, start\n  while ((matchArr = regex.exec(text)) !== null) {\n    start = matchArr.index\n    callback(start, start + matchArr[0].length)\n  }\n}\n\nconst signatureDecorator = new CompositeDecorator([\n  {\n    //TypeBadge\n    strategy(contentBlock, cb, contentState) {\n      findWithRegex(\n        new RegExp(\n          `(${typeSuggestions.map(({ title }) => title).join('|')})`,\n          'gi',\n        ),\n        contentBlock,\n        cb,\n      )\n    },\n    component(props: any) {\n      return (\n        <TypeBadge\n          typeAsString={props.decoratedText}\n          children={props.children}\n          as='span'\n        />\n      )\n    },\n  },\n])\n\nconst HANDLE_REGEX = /@[\\w]+/g\n\nconst getStateValueFromFunc = (\n  descriptionDecorator: CompositeDecorator,\n  func?: Ifunction,\n): {\n  name: string\n  signature: EditorState\n  description: EditorState\n  code: string\n} => {\n  return {\n    name: func?.name || '',\n    signature: EditorState.createWithContent(\n      ContentState.createFromText(\n        func?.parameters\n          .concat(func.returns)\n          .map(p => p.type)\n          .join(` ${arrow} `) || '',\n      ),\n      signatureDecorator,\n    ),\n    description: EditorState.createWithContent(\n      ContentState.createFromText(func?.description || ''),\n      descriptionDecorator,\n    ),\n    code: func?.fn.toString() || '',\n  }\n}\n\ntype DocsCardState = {\n  name: string\n  signature: EditorState\n  description: EditorState\n  code: string\n}\n\nconst setOriginalState = (\n  originalState: React.MutableRefObject<{\n    name: string\n    signatureString: string\n    descriptionString: string\n    code: string\n  }>,\n  state: DocsCardState,\n) => {\n  const newOriginalState = {\n    name: state.name,\n    signatureString: state.signature.getCurrentContent().getPlainText(),\n    descriptionString: state.description.getCurrentContent().getPlainText(),\n    code: state.code,\n  }\n\n  originalState.current = newOriginalState\n}\n\n/**\n *\n *\n * DOCS CARD\n *\n *\n */\n\nconst DocsCard = ({\n  func,\n  dispatch,\n  index,\n  functions,\n  navigationType,\n}: {\n  func?: Ifunction\n  dispatch: React.Dispatch<Action>\n  index: number\n  functions: Ifunction[]\n  navigationType?: NavigationType\n}) => {\n  const descriptionDecorator = new CompositeDecorator([\n    {\n      //TypeBadge\n      strategy(contentBlock, cb, contentState) {\n        findWithRegex(HANDLE_REGEX, contentBlock, cb)\n      },\n      component(props: any) {\n        return (\n          <Button\n            as='span'\n            variant='link'\n            color='unison.aqua'\n            fontSize='inherit'\n            fontStyle='inherit'\n            style={{\n              direction: 'ltr',\n              unicodeBidi: 'bidi-override',\n            }}\n            data-offset-key={props.offsetKey}\n            onClick={e => {\n              dispatch({\n                type: 'openDocs',\n                openerIndex: index,\n                fnName: props.decoratedText.slice(1),\n              })\n            }}\n          >\n            {props.children}\n          </Button>\n        )\n      },\n    },\n  ])\n  const originalState = React.useRef<{\n    name: string\n    signatureString: string\n    descriptionString: string\n    code: string\n  }>({\n    name: '',\n    signatureString: '',\n    descriptionString: '',\n    code: '',\n  })\n  const [state, setState] = React.useState<DocsCardState>(() => {\n    const state = getStateValueFromFunc(descriptionDecorator, func)\n    setOriginalState(originalState, state)\n    return state\n  })\n\n  const [previousFunc, setPreviousFunc] = React.useState(func)\n  if (previousFunc !== func) {\n    //reference check on function from state.functions\n    setPreviousFunc(func)\n    const state = getStateValueFromFunc(descriptionDecorator, func)\n    setOriginalState(originalState, state)\n    setState(state)\n  }\n  const { name, signature, description, code } = state\n\n  /* Name */\n  const onChangeName = (name: string) => setState(state => ({ ...state, name }))\n  const nameFontStyle = [defaultName, ''].includes(name) ? 'italic' : 'normal'\n  const nameColor = [defaultName, ''].includes(name) ? 'gray.400' : 'normal'\n\n  /* Description */\n  const onChangeDescription = (description: EditorState) =>\n    setState(state => ({ ...state, description }))\n  const descriptionHasText = description.getCurrentContent().hasText()\n  const descriptionFontStyle = descriptionHasText ? 'normal' : 'italic'\n  const descriptionColor = descriptionHasText ? 'normal' : 'gray.400'\n  // const descriptionEditorRef = React.useRef(null)\n  const [\n    autocompleteDescription,\n    setAutocompleteDescription,\n  ] = React.useState<any>(null)\n  const filteredFunctions = getFilteredFunctions(\n    functions,\n    autocompleteDescription?.text,\n  )\n\n  /* Signature */\n\n  // const [signatureEditorState, setSignatureEditorState] = React.useState(() =>\n  //   EditorState.createEmpty(signatureDecorator),\n  // )\n  const signatureEditorRef = React.useRef<DraftEditor>(null)\n  const signatureEditorParentRef = React.useRef<HTMLElement>(null)\n  const coordsSignatureEditor = React.useRef<any>(null)\n\n  const onChangeSignatureEditor = (e: EditorState) => {\n    let newEditorState: EditorState\n    switch (e.getLastChangeType()) {\n      case 'insert-characters':\n        const text = e.getCurrentContent().getFirstBlock().getText()\n        let newText = text\n        const triggerArrow = text.endsWith(',') || text.endsWith(' ')\n        if (triggerArrow) {\n          //TODO arrow component\n          const previousMeaningfulCharIsArrow = text\n            .replace(',', ' ')\n            .trimEnd()\n            .endsWith(arrow)\n          const previousCharIsClosingBracket = text\n            .substr(0, text.length - 1)\n            .endsWith('}')\n          if (previousMeaningfulCharIsArrow) {\n            newText = text //.substr(0, text.length - 1)\n          } else if (previousCharIsClosingBracket && text.endsWith(' ')) {\n            //abilities\n            newText = text\n          } else {\n            // only if last non-space or comma char is not arrow\n            newText = text.substr(0, text.length - 1).concat(` ${arrow} `)\n          }\n        }\n\n        newEditorState =\n          text === newText\n            ? e\n            : EditorState.moveFocusToEnd(\n                EditorState.push(\n                  e,\n                  ContentState.createFromText(newText),\n                  'insert-fragment',\n                ),\n              )\n        break\n      default:\n        newEditorState = e\n        break\n    }\n    setState(state => ({ ...state, signature: newEditorState }))\n\n    /* autocomplete */\n\n    window.requestAnimationFrame(() => {\n      const selection = window.getSelection() as Selection\n      if (selection.rangeCount === 0) {\n        //focus is outside\n        setAutocompleteState(null)\n        return\n      }\n      const stateSelection = newEditorState.getSelection()\n      // const contentState = newEditorState.getCurrentContent()\n      // const block = contentState.getBlockForKey(stateSelection.getStartKey())\n      if (\n        !stateSelection.getHasFocus() /*||\n        block.getEntityAt(stateSelection.getStartOffset() - 1*/\n      ) {\n        setAutocompleteState(null)\n        return\n      }\n      const range = selection.getRangeAt(0)\n      // let text = range.startContainer.textContent//!.substring(\n      //b|oolean -> 'b\n      //0,\n      //range.startOffset,\n      //)\n      // console.log(1, { text, stateSelection })\n      const wholeWordText = range.startContainer.textContent as string //b|oolean -> 'boolean'\n      let index = wholeWordText.length > 0 ? wholeWordText.lastIndexOf(' ') : 0\n      index = index === -1 ? 0 : index\n      const text = wholeWordText.substring(index).trim()\n\n      // console.log(3, { text })\n\n      let { left } = range.getBoundingClientRect()\n      const editorParent = signatureEditorParentRef.current as HTMLElement\n      const coords =\n        coordsSignatureEditor.current ?? editorParent.getBoundingClientRect()\n      coordsSignatureEditor.current = coords //TODO reset this cache\n      let top = coords.bottom\n      if (left === 0) {\n        left = coords.left\n      }\n\n      setAutocompleteState({\n        left,\n        top,\n        text,\n        wholeWordText,\n        startIndex: index,\n        selectedIndex: 0,\n      })\n    })\n  }\n  const handleKeyCommand = (command: 'up' | 'down' | 'close' | 'select') => {\n    switch (command) {\n      case 'up': {\n        setAutocompleteState((state: any) => ({\n          ...state,\n          selectedIndex:\n            state.selectedIndex === 0 ? 0 : state.selectedIndex - 1,\n        }))\n        return 'handled'\n      }\n      case 'down': {\n        setAutocompleteState((state: any) => ({\n          ...state,\n          selectedIndex:\n            state.selectedIndex === filteredSuggestions.length - 1\n              ? filteredSuggestions.length - 1\n              : state.selectedIndex + 1,\n        }))\n        return 'handled'\n      }\n      case 'close': {\n        signatureEditorRef.current!.blur()\n        return 'handled'\n      }\n      case 'select': {\n        const currentSelectionState = signature.getSelection()\n        const anchorOffset /*end */ = currentSelectionState.getAnchorOffset()\n        const anchorKey = currentSelectionState.getAnchorKey()\n        const currentContent = signature.getCurrentContent()\n        const currentBlock = currentContent.getBlockForKey(anchorKey)\n        const blockText = currentBlock.getText()\n        console.log({\n          blockText,\n          signatureString,\n          text: autocompleteState.text,\n          wholeWordText: autocompleteState.wholeWordText,\n          anchorOffset,\n          anchorKey,\n        })\n        // const start = blockText.substring(0, end).lastIndexOf(trigger)\n        // return {\n        // editorState,\n        // start,\n        // end,\n        // trigger,\n        // selectedIndex: autocompleteState.selectedIndex,\n        // }\n\n        // add suggestion\n        const textToInsert =\n          filteredSuggestions[autocompleteState.selectedIndex].title\n        const newCurrentContent = currentContent.createEntity(\n          'TYPE',\n          'IMMUTABLE',\n        )\n        const entityKey = newCurrentContent.getLastCreatedEntityKey()\n        const mentionTextSelection = currentSelectionState.merge({\n          anchorOffset: autocompleteState.startIndex,\n          focusOffset: anchorOffset,\n        })\n        let insertingContent = Modifier.replaceText(\n          signature.getCurrentContent(),\n          mentionTextSelection,\n          textToInsert,\n          undefined,\n          // ['link', 'BOLD'],\n          entityKey,\n        )\n        const newEditorState = EditorState.push(\n          signature,\n          insertingContent,\n          'apply-entity',\n        )\n        setState(state => ({ ...state, signature: newEditorState }))\n\n        // EditorState.forceSelection(\n        //   newEditorState,\n        //   insertingContent.getSelectionAfter(),\n        // ),\n\n        return 'handled'\n      }\n      default:\n        return 'not-handled'\n    }\n  }\n\n  const [autocompleteState, setAutocompleteState] = React.useState<any>(null)\n  const filteredSuggestions = getFilteredTypeSuggestions(\n    typeSuggestions,\n    autocompleteState?.text,\n  )\n\n  /* Code */\n\n  const onChangeCode = (code: string) => setState(state => ({ ...state, code }))\n  const signatureString = signature.getCurrentContent().getPlainText()\n  const paramsAndReturns = getParamsAndReturns(signatureString)\n  const params = paramsAndReturns.slice(0, paramsAndReturns.length - 1)\n  const paramNames = getParamNames(params)\n  const editorValue =\n    code || `function ${name || 'name'}(${paramNames.join(', ')}) {\\n\\n}`\n\n  // const [signatureTouched, setSignatureTouched] = React.useState<boolean>(false)\n  const signatureError = !isSignatureCorrect(paramsAndReturns)\n\n  const hasChanges =\n    name !== originalState.current.name ||\n    signatureString !== originalState.current.signatureString ||\n    description.getCurrentContent().getPlainText() !==\n      originalState.current.descriptionString ||\n    code !== originalState.current.code\n\n  const onSaveButtonClick = () => {\n    const fn = safeEval(code)\n    const validParams = isSignatureCorrect(paramsAndReturns)\n    if (!fn || !validParams) {\n      return //TODO alert\n    }\n    const parameters = paramsAndReturns.slice(\n      0,\n      paramsAndReturns.length - 1,\n    ) as Itype[] //TODO cast\n    const returns = paramsAndReturns.slice(-1).pop() as Itype\n    dispatch({\n      type: 'createFunction',\n      function: {\n        name,\n        parameters,\n        returns,\n        fn,\n        description: description.getCurrentContent().getPlainText(),\n      },\n      index,\n    })\n  }\n\n  const onClearButtonClick = useCallback(() => {\n    const state = getStateValueFromFunc(descriptionDecorator, undefined)\n    setOriginalState(originalState, state)\n    setState(state)\n    dispatch({ type: 'clearDocsCard', index })\n  }, [originalState, index])\n\n  return (\n    <Box\n      boxShadow={'base'}\n      backgroundColor='white'\n      padding={1}\n      minWidth='48%'\n      minHeight='99vh'\n      height='100%'\n      // position='relative'\n      display='flex'\n      flexDirection='column'\n    >\n      <Flex paddingLeft={2} alignItems='center'>\n        <Heading fontSize='xl' fontStyle='italic' color='unison.purple'>\n          Docs\n        </Heading>\n        {navigationType === 'history' ? (\n          <DocsNavigationArrows></DocsNavigationArrows>\n        ) : null}\n        <Spacer></Spacer>\n        <ClearButton\n          onClick={onClearButtonClick}\n          fadeIn={hasChanges}\n        ></ClearButton>\n        <SaveButton\n          onClick={onSaveButtonClick}\n          fadeIn={hasChanges}\n          disabled={signatureError}\n        ></SaveButton>\n        <DocsExplanation />\n        {navigationType ? (\n          <DocsNavigationTypeSelector\n            dispatch={dispatch}\n            navigationType={navigationType}\n          ></DocsNavigationTypeSelector>\n        ) : null}\n        <IconButton\n          /* Close Button */\n          aria-label='Close card'\n          icon={<CloseIcon />}\n          variant='ghost'\n          size='sm'\n          onClick={() => dispatch({ type: 'closeDocsCard', index })}\n        />\n      </Flex>\n      <Divider marginTop={2}></Divider>\n      <Droppable droppableId='DocsCard'>\n        {(provided, snapshot) => {\n          return (\n            <Box\n              ref={provided.innerRef}\n              {...provided.droppableProps}\n              // minWidth={'50%'}\n              flex={1}\n              minHeight='100%'\n              height='100%'\n              overflow='auto'\n              paddingX={2}\n              paddingY={2}\n            >\n              <EditableText\n                /* NAME */\n                value={name}\n                onChange={onChangeName}\n                placeholder={defaultName}\n                fontSize='2xl'\n                textColor={nameColor}\n                fontStyle={nameFontStyle}\n                marginBottom={3}\n              />\n\n              {/* SIGNATURE */}\n              <HStack>\n                <Code fontSize='sm' padding={0.5}>\n                  <Editable\n                    as='span'\n                    placeholder={defaultName}\n                    fontStyle={nameFontStyle}\n                    // width={name.length * 12 + 12 + 'px'}\n                    width={(name.length > 3 ? name.length : 4) * 9 + 9 + 'px'}\n                    // minWidth={(name || defaultName).length * 12 + 12 + 'px'}\n                    value={name}\n                    textColor={nameColor}\n                    onChange={onChangeName}\n                    paddingX={1}\n                  >\n                    <EditablePreview\n                      width={(name.length > 3 ? name.length : 4) * 9 + 9 + 'px'}\n                    />\n                    <EditableInput\n                      width={(name.length > 3 ? name.length : 4) * 9 + 9 + 'px'}\n                      _focus={{\n                        outline: '',\n                      }}\n                    />\n                  </Editable>\n                </Code>\n\n                <Text as='span' fontSize='sm'>\n                  :{' '}\n                </Text>\n                <Code\n                  // SIGNATURE EDITOR\n                  fontSize='sm'\n                  width='100%'\n                  paddingX={1}\n                  paddingY={1}\n                  as='span'\n                  ref={signatureEditorParentRef}\n                  // position='relative'\n                >\n                  <DraftEditor\n                    editorState={signature}\n                    ref={signatureEditorRef}\n                    onChange={onChangeSignatureEditor}\n                    keyBindingFn={autocompleteKeyBindingFn}\n                    handleKeyCommand={handleKeyCommand}\n\n                    // onBlur={(e: any) => {\n                    //   setSignatureTouched(true)\n                    // }}\n                  />\n                  {filteredSuggestions.length > 0 ? (\n                    <TypeSuggestionList\n                      typeSuggestions={filteredSuggestions}\n                      selectedIndex={autocompleteState.selectedIndex}\n                      left={autocompleteState.left}\n                      top={autocompleteState.top}\n                    ></TypeSuggestionList>\n                  ) : null}\n                </Code>\n              </HStack>\n\n              <Text\n                /* DESCRIPTION */\n                className='description'\n                marginTop={5}\n                fontSize='xl'\n                fontStyle={descriptionFontStyle}\n                color={descriptionColor}\n                backgroundColor='yellow.50'\n                padding={3}\n              >\n                <DraftEditor\n                  placeholder='Description'\n                  editorState={description}\n                  onChange={onChangeDescription}\n                ></DraftEditor>\n              </Text>\n              {/* <Tabs marginTop={5}>\n                <TabList>\n                  <Tab>Regular editor</Tab>\n                  <Tab>Structured editor</Tab>\n                </TabList>\n                <TabPanels>\n                  <TabPanel> */}\n              <Box marginTop={5}>\n                <MonacoEditor\n                  value={editorValue}\n                  onChange={(_: any, v: any) => {\n                    onChangeCode(v)\n                  }}\n                ></MonacoEditor>\n              </Box>\n\n              {/* </TabPanel>\n                  <TabPanel>\n                    <Code>{editorValue}</Code>\n                  </TabPanel>\n                </TabPanels>\n              </Tabs> */}\n\n              {provided.placeholder}\n            </Box>\n          )\n        }}\n      </Droppable>\n    </Box>\n  )\n}\nexport default DocsCard\n","import * as React from 'react'\nimport {\n  ControlledEditor,\n  ControlledEditorOnChange,\n} from '@monaco-editor/react'\nfunction Editor({\n  value,\n  onChange,\n}: {\n  value: string\n  onChange: ControlledEditorOnChange\n}) {\n  // function onChange(newValue: any, e: any) {\n  //   console.log('onChange', newValue, e)\n  // }\n\n  // const code = this.state.code;\n  const options: { lineNumbers: 'off'; minimap: { enabled: boolean } } = {\n    // selectOnLineNumbers: true,\n    minimap: { enabled: false },\n    lineNumbers: 'off',\n  }\n  return (\n    <ControlledEditor\n      width='100%'\n      height='30vh'\n      language='javascript'\n      theme='vs-light'\n      value={value}\n      options={options}\n      onChange={onChange}\n      // editorDidMount={(editor, monaco) =>\n      //   console.log('editorDidMount', { editor, monaco })\n      // }\n    />\n  )\n}\nexport default Editor\n","import * as React from 'react'\nimport {\n  EditableProps,\n  Editable,\n  EditablePreview,\n  EditableInput,\n  forwardRef,\n} from '@chakra-ui/react'\n\nconst EditableText = forwardRef((props: EditableProps, ref) => (\n  <Editable {...props}>\n    <EditablePreview />\n    <EditableInput\n      ref={ref}\n      _focus={{\n        outline: '',\n      }}\n    />\n  </Editable>\n))\n\nexport default EditableText\n","import * as React from 'react'\nimport { Droppable, Draggable } from 'react-beautiful-dnd'\nimport type { Ieffect, Itype, Ifunction } from './interfaces'\nimport {\n  Box,\n  Code,\n  forwardRef,\n  Input,\n  InputGroup,\n  InputLeftElement,\n  Text,\n  Kbd,\n  ListItem,\n  UnorderedList,\n  Center,\n  useTheme,\n  InputRightElement,\n  InputRightAddon,\n  HStack,\n} from '@chakra-ui/react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport TreeView from '@material-ui/lab/TreeView'\nimport TreeItem from '@material-ui/lab/TreeItem'\nimport {\n  ChevronDownIcon,\n  ChevronRightIcon,\n  ArrowForwardIcon,\n  SearchIcon,\n} from '@chakra-ui/icons'\nimport { FaShapes } from 'react-icons/fa'\n// import { VscSymbolMisc as FaShapes } from 'react-icons/vsc'\nimport { GiMineExplosion } from 'react-icons/gi'\n// import { IoShapes } from 'react-icons/io' //RiFunctionLine, RiFunctionFill //IoShapesOutline\nimport './sideBarStyles.css'\nimport TypeBadge from './TypeBadge'\nimport { Action } from '../state'\nimport MouseTrap from 'mousetrap'\n// import { FlowFunctionView } from './FlowCard'\nimport PopoverExplanation from './PopoverExplanation'\n\ntype IsideBarItem =\n  | {\n      nodeId: 'functions'\n      label: 'Functions'\n      items: Array<Ifunction>\n    }\n  | {\n      nodeId: 'types'\n      label: 'Data Types'\n      items: Array<Itype>\n    }\n  | {\n      nodeId: 'effects'\n      label: 'Effects'\n      items: Array<Ieffect>\n    }\n\nexport const FunctionItem = (props: Ifunction) => {\n  return (\n    <Text\n      wrap='nowrap'\n      color='unison.purple'\n      _hover={{ color: 'unison.lightPurple' }}\n    >\n      <Code\n        fontSize='sm'\n        // fontWeight='700'\n        paddingX={1}\n        paddingY={0.5}\n        rounded='base'\n        backgroundColor='transparent'\n        color='inherit'\n      >\n        {props.name}\n      </Code>\n      <Text as='span'>: </Text>\n      <Text as={'span'} flexWrap='nowrap'>\n        {props.parameters.map((p, i) => (\n          <Text as='span' key={i}>\n            <TypeBadge typeAsString={p.type} />\n            <ArrowForwardIcon marginX={1} />\n          </Text>\n        ))}\n      </Text>\n      <TypeBadge typeAsString={props.returns.type} />\n    </Text>\n  )\n}\n\nconst getFunctionRenderItem = (props: Ifunction) => (\n  provided: any,\n  snapshot: any,\n  rubric: any,\n) => {\n  return (\n    <div\n      {...provided.draggableProps}\n      {...provided.dragHandleProps}\n      ref={provided.innerRef}\n      style={provided.draggableProps.style}\n    >\n      <div>\n        <FunctionItem {...props} />\n        {/* <FlowFunctionView item={{ ...props }} /> */}\n      </div>\n    </div>\n  )\n}\nconst useTreeItemStyles = makeStyles({\n  root: {\n    marginBottom: '5px',\n  },\n  content: {\n    '&:hover': {\n      backgroundColor: 'transparent',\n      cursor: 'grabbing',\n    },\n  },\n})\n\nconst FunctionTreeItem = (\n  props: Ifunction & { nodeId: string; isAnyItemDragging: boolean },\n) => {\n  const { root, content } = useTreeItemStyles()\n  return (\n    <TreeItem\n      classes={{ root, content: props.isAnyItemDragging ? content : undefined }}\n      nodeId={props.nodeId}\n      label={\n        <Droppable\n          droppableId={props.nodeId}\n          renderClone={getFunctionRenderItem(props)}\n          isDropDisabled={true}\n        >\n          {(provided, snapshot) => {\n            const shouldRenderClone =\n              props.nodeId === snapshot.draggingFromThisWith\n            return (\n              <div ref={provided.innerRef} {...provided.droppableProps}>\n                {shouldRenderClone ? (\n                  <div className='react-beautiful-dnd-copy'>\n                    <FunctionItem {...props}></FunctionItem>\n                  </div>\n                ) : (\n                  <Draggable draggableId={props.nodeId} index={0}>\n                    {(provided, snapshot) => {\n                      return (\n                        <div\n                          ref={provided.innerRef}\n                          {...provided.draggableProps}\n                          {...provided.dragHandleProps}\n                        >\n                          <FunctionItem {...props}></FunctionItem>\n                        </div>\n                      )\n                    }}\n                  </Draggable>\n                )}\n                {/* {provided.placeholder} */}\n              </div>\n            )\n          }}\n        </Droppable>\n      }\n    ></TreeItem>\n  )\n}\nconst TypeTreeItem = (\n  props: Itype & { nodeId: string; isAnyItemDragging: boolean },\n) => {\n  const { content } = useTreeItemStyles()\n  return (\n    <TreeItem\n      nodeId={props.nodeId}\n      classes={{ content: props.isAnyItemDragging ? content : undefined }}\n      label={<TypeBadge typeAsString={props.type}></TypeBadge>}\n    />\n  )\n}\n\nconst Sidebar = React.memo(\n  forwardRef(\n    (\n      {\n        items,\n        isAnyItemDragging,\n        dispatch,\n        searchValue,\n      }: {\n        items: Array<IsideBarItem>\n        isAnyItemDragging: boolean\n        dispatch: React.Dispatch<Action>\n        searchValue: string\n      },\n      ref,\n    ) => {\n      const theme = useTheme()\n      const {\n        colors: {\n          unison: { purple, lightPurple, aqua },\n        },\n      } = theme\n\n      //Search\n      const [isHoveringSearch, setIsHoveringSearch] = React.useState(false)\n      const [isFocusedSearch, setFocusedSearch] = React.useState(false)\n      const onMouseEnterSearch = React.useCallback(() => {\n        setIsHoveringSearch(true)\n      }, [])\n      const onMouseLeaveSearch = React.useCallback(() => {\n        setIsHoveringSearch(false)\n      }, [])\n\n      return (\n        <Box\n          height='100%'\n          flex={1}\n          backgroundColor={'purple.50'}\n          paddingTop={4}\n        >\n          <InputGroup\n            width='100%'\n            whiteSpace='nowrap'\n            padding={1}\n            display='flex'\n            onMouseEnter={onMouseEnterSearch}\n            onMouseLeave={onMouseLeaveSearch}\n            // _focusWithin={{ color: 'teal.600' }}\n          >\n            <InputLeftElement\n              pointerEvents='none'\n              children={\n                <SearchIcon\n                  color={\n                    isFocusedSearch\n                      ? aqua\n                      : isHoveringSearch\n                      ? lightPurple\n                      : purple\n                  }\n                />\n              } //TODO teal\n            />\n            <Input\n              ref={ref}\n              placeholder='Search'\n              variant='outline'\n              _hover={{ borderBottomColor: lightPurple }}\n              focusBorderColor={'unison.aqua'}\n              size='md'\n              borderRadius='0%'\n              borderTop='none'\n              borderLeft='none'\n              borderRight='none'\n              borderBottom={`2px solid ${purple}`}\n              value={searchValue}\n              onFocus={() => {\n                if (!ref || !('current' in ref)) return\n                ref.current.setSelectionRange(0, ref.current.value.length)\n                setFocusedSearch(true)\n              }}\n              onBlur={() => setFocusedSearch(false)}\n              onChange={e =>\n                dispatch({ type: 'sideBarSearch', value: e.target.value })\n              }\n            />\n            {isHoveringSearch ? (\n              <HStack\n                background='transparent'\n                position='absolute'\n                right={2}\n                top={2}\n                pointerEvents='none'\n              >\n                <Kbd>ctrl</Kbd>\n                <Text>/</Text>\n                <Kbd>⌘</Kbd>\n                <Text>+</Text>\n                <Kbd>B</Kbd>\n              </HStack>\n            ) : null}\n          </InputGroup>\n          <Center>\n            <PopoverExplanation label='Sidebar explanation' title='Sidebar'>\n              <UnorderedList>\n                <ListItem>\n                  Drag functions and drop them onto Flow Card or Docs Card\n                </ListItem>\n                <ListItem>\n                  <Kbd>up</Kbd>, <Kbd>down</Kbd>, <Kbd>left</Kbd>,{' '}\n                  <Kbd>right</Kbd> to move in Sidebar\n                </ListItem>\n                <ListItem>\n                  <Kbd>space</Kbd> to drag, <Kbd>right</Kbd> then{' '}\n                  <Kbd>space</Kbd> to drop\n                </ListItem>\n                <ListItem>\n                  Datatypes and Effects are not interactive at this point\n                </ListItem>\n              </UnorderedList>\n            </PopoverExplanation>\n          </Center>\n\n          <TreeView\n            selected={[]}\n            aria-label='Functions, types and effects'\n            defaultCollapseIcon={<ChevronDownIcon color='unison.purple' />}\n            defaultExpandIcon={<ChevronRightIcon color='unison.purple' />}\n            onNodeFocus={(e, v) => {\n              const draggable: any = document.querySelector(\n                `[data-rbd-draggable-id=\"${v}\"]`,\n              )\n\n              if (draggable) {\n                const focused = document.querySelectorAll('.Mui-focused')\n                focused.forEach(e => {\n                  e.classList.remove('Mui-focused')\n                })\n                const div =\n                  draggable.parentElement?.parentElement?.parentElement\n                const li = div?.parentElement\n                const parentMenu =\n                  li?.parentElement?.parentElement?.parentElement?.parentElement\n                const previous = li?.previousElementSibling\n                const next = li?.nextElementSibling\n\n                if (!draggable.bound) {\n                  draggable.bound = true\n                  MouseTrap(draggable).bind('left', e => {\n                    if (isAnyItemDragging) {\n                      return\n                    }\n                    div?.classList.remove('Mui-focused')\n                    parentMenu?.focus()\n                  })\n                  MouseTrap(draggable).bind('down', e => {\n                    if (isAnyItemDragging) {\n                      return\n                    }\n                    if (next) {\n                      next.focus()\n                      div?.classList.remove('Mui-focused')\n                    } else {\n                      parentMenu?.nextElementSibling?.focus()\n                      div?.classList.remove('Mui-focused')\n                    }\n                  })\n                  MouseTrap(draggable).bind('up', e => {\n                    if (isAnyItemDragging) {\n                      return\n                    }\n                    if (previous) {\n                      previous.focus()\n                      div?.classList.remove('Mui-focused')\n                    } else {\n                      parentMenu?.focus()\n                      div?.classList.remove('Mui-focused')\n                    }\n                  })\n                }\n\n                div?.classList.add('Mui-focused')\n                draggable.focus()\n              }\n            }}\n          >\n            {items &&\n              items.map(item => {\n                const label = (\n                  <Text fontSize='lg' color={'unison.purple'}>\n                    {item.label}\n                  </Text>\n                )\n                return (\n                  <TreeItem\n                    nodeId={item.nodeId}\n                    key={item.nodeId}\n                    label={\n                      <HStack>\n                        {item.nodeId === 'functions' ? (\n                          <Text fontWeight='bold' fontSize='xl' color={purple}>\n                            λ\n                          </Text>\n                        ) : item.nodeId === 'types' ? (\n                          <FaShapes color={purple} />\n                        ) : item.nodeId === 'effects' ? (\n                          <GiMineExplosion color={purple} />\n                        ) : null}\n                        {label}\n                      </HStack>\n                    }\n                  >\n                    {(() => {\n                      switch (item.nodeId) {\n                        case 'functions':\n                          return item.items.map(innerItem => {\n                            const id = `${item.nodeId}_${innerItem.name}`\n                            return (\n                              <FunctionTreeItem\n                                {...innerItem}\n                                key={id}\n                                nodeId={id}\n                                isAnyItemDragging={!!isAnyItemDragging}\n                              />\n                            )\n                          })\n                        case 'types':\n                          return item.items.map(innerItem => {\n                            const id = `${item.nodeId}_${innerItem.type}`\n                            return (\n                              <TypeTreeItem\n                                {...innerItem}\n                                key={id}\n                                nodeId={id}\n                                isAnyItemDragging={!!isAnyItemDragging}\n                              />\n                            )\n                          })\n                        case 'effects':\n                          return null //@TODO\n                        default:\n                          let _: never = item\n                      }\n                    })()}\n                  </TreeItem>\n                )\n              })}\n          </TreeView>\n        </Box>\n      )\n    },\n  ),\n)\n\nexport default Sidebar\n","import * as React from 'react'\nimport { HStack } from '@chakra-ui/react'\n\nconst CardHStack = ({ children }: { children?: any }) => {\n  return (\n    <HStack\n      // overflowY='scroll'\n      overflowX='scroll'\n      // height='100%'\n      // flex='1'\n      // padding={1}\n      width={'100%'}\n      backgroundColor='purple.50'\n    >\n      {children}\n    </HStack>\n  )\n}\nexport default CardHStack\n","import * as React from 'react'\nimport { Droppable, Draggable } from 'react-beautiful-dnd'\nimport { Ifunction, Itype } from './interfaces'\nimport {\n  Box,\n  Flex,\n  Center,\n  Spacer,\n  Code,\n  HStack,\n  VStack,\n  forwardRef,\n  Divider,\n  Button,\n  Input,\n  NumberInput,\n  NumberInputField,\n  NumberInputStepper,\n  NumberIncrementStepper,\n  NumberDecrementStepper,\n  Checkbox,\n  Text,\n  Heading,\n  Grid,\n  GridItem,\n  Fade,\n} from '@chakra-ui/react'\nimport {\n  ArrowDownIcon,\n  ArrowForwardIcon,\n  DeleteIcon,\n  PlusSquareIcon,\n} from '@chakra-ui/icons'\nimport TypeBadge from './TypeBadge'\nimport { Action } from '../state'\nimport PopoverExplanation from './PopoverExplanation'\nimport './flowCardStyles.css'\n// import { Fade } from '@material-ui/core'\n// import produce from 'immer'\n// import EditableText from './EditableText'\n\nconst TypeAndValue = React.memo(\n  ({\n    type,\n    value,\n    onChange,\n    direction,\n  }: {\n    type: Itype['type']\n    value: any\n    onChange?: (v: string | number | boolean) => void\n    direction: 'row' | 'column'\n  }) => {\n    return (\n      <Flex direction={direction} justifyContent='center' alignItems='center'>\n        <TypeBadge typeAsString={type} />\n        {(() => {\n          if (!onChange) {\n            return (\n              <Code>\n                {type === 'boolean' ? (value ? 'true' : 'false') : value}\n              </Code>\n            )\n          }\n          switch (type) {\n            case 'string':\n              return (\n                <Input\n                  size='sm'\n                  value={value}\n                  variant='outline'\n                  backgroundColor='white'\n                  focusBorderColor={'unison.aqua'}\n                  rounded='base'\n                  onChange={e => {\n                    onChange(e.target.value)\n                  }}\n                ></Input>\n              )\n            case 'number':\n              return (\n                <NumberInput\n                  size='sm'\n                  value={value}\n                  variant='outline'\n                  backgroundColor='white'\n                  focusBorderColor={'unison.aqua'}\n                  rounded='base'\n                  onChange={(s, n) => {\n                    if (isNaN(Number(n))) {\n                      return\n                    }\n                    onChange(n)\n                  }}\n                  allowMouseWheel\n                >\n                  <NumberInputField />\n                  {/* <NumberInputStepper> */}\n                  {/* <NumberIncrementStepper /> */}\n                  {/* <NumberDecrementStepper /> */}\n                  {/* </NumberInputStepper> */}\n                </NumberInput>\n              )\n            case 'boolean':\n              console.log({ type, value })\n              return (\n                <Checkbox\n                  isChecked={value}\n                  onChange={e => {\n                    onChange(e.target.checked)\n                  }}\n                >\n                  {value ? 'true' : 'false'}\n                </Checkbox>\n              )\n            default:\n              return null\n          }\n        })()}\n      </Flex>\n    )\n  },\n)\n\nconst getParamValues = (\n  items: IfunctionWithId[],\n  v: string | number | boolean,\n  paramIndex: number | 'last',\n) => {\n  let previousReturn = null\n  let newItems: IfunctionWithId[] = []\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i]\n    const parameters = [...item.parameters]\n    if (i === 0) {\n      //donde se ha producido el cambio\n      const param =\n        paramIndex === 'last'\n          ? parameters[parameters.length - 1]\n          : parameters[paramIndex]\n      param.value = v\n    }\n    const previouslastParam: Itype | undefined =\n      parameters[parameters.length - 1]\n\n    if (previouslastParam) {\n      parameters[parameters.length - 1] = {\n        ...previouslastParam,\n        value:\n          previousReturn === null ? previouslastParam?.value : previousReturn,\n      }\n    }\n\n    //TODO typecheck\n\n    console.log({ parameters })\n    let returnValue\n    try {\n      returnValue = item.fn(...parameters.map(p => p.value))\n    } catch (error) {\n      console.log({ error })\n      break\n    }\n    console.log('break')\n\n    newItems.push({\n      ...item,\n      parameters,\n      returns: { ...item.returns, value: returnValue },\n    })\n\n    previousReturn = returnValue\n  }\n\n  return newItems\n}\n\nfunction sliceInTwo<A>(i: number, as: A[]) {\n  return [as.slice(0, i), as.slice(i)]\n}\n\nconst C_TypeAndValue = React.memo(\n  ({\n    fnId,\n    direction,\n    paramIndex,\n    noInput = false,\n  }: {\n    fnId: string\n    direction: 'row' | 'column'\n    paramIndex: number | 'last' | 'return'\n    noInput?: boolean\n  }) => {\n    const { fns, setFns } = React.useContext(ParameterContext)\n    const { parameters, returns, id } = fns.find(({ id }) => id === fnId)!\n    const param =\n      paramIndex === 'return'\n        ? returns\n        : paramIndex === 'last'\n        ? parameters[parameters.length - 1]\n        : parameters[paramIndex]\n\n    const onChange =\n      noInput || paramIndex === 'return'\n        ? undefined\n        : (v: string | number | boolean) => {\n            const [previousFns, affectedFns] = sliceInTwo(\n              fns.findIndex(({ id }) => id === fnId),\n              fns,\n            )\n            const newValues = getParamValues(affectedFns, v, paramIndex)\n            console.log({ previousFns, affectedFns, newValues })\n            setFns(previousFns.concat(newValues))\n          }\n\n    return (\n      <TypeAndValue\n        type={param.type}\n        value={param.value}\n        onChange={onChange}\n        direction={direction}\n      />\n    )\n  },\n)\n\nexport const FlowFunctionView = React.memo(\n  forwardRef(\n    (\n      {\n        item,\n        // style,\n        // onChangeParam,\n        isFirstFunctionInFlow,\n        ...rest\n      }: {\n        item: Ifunction & { id: string }\n        // style?: React.CSSProperties\n        isFirstFunctionInFlow: boolean\n        // onChangeParam: (_: {\n        //   paramValue: string | number | boolean\n        //   paramIndex: number\n        // }) => void\n      },\n      ref,\n    ) => {\n      const hasZeroParams = item.parameters.length === 0\n      const hasOneParam = item.parameters.length === 1\n      return (\n        <Grid\n          {...rest}\n          ref={ref}\n          backgroundColor='gray.200' //TODO\n          rounded='md'\n          marginBottom={1}\n          padding={1}\n          templateColumns='auto 25%'\n          width='100%'\n          gap={1}\n        >\n          <GridItem\n            width='100%'\n            display='flex'\n            flexDirection='row'\n            alignItems='center'\n          >\n            <Code justifySelf='flex-start' backgroundColor='transparent'>\n              {item.name}\n            </Code>\n\n            {hasZeroParams || hasOneParam\n              ? null\n              : item.parameters\n                  .slice(0, item.parameters.length - 1)\n                  .map((param, i) => {\n                    const css =\n                      i === item.parameters.length - 2\n                        ? { transform: 'rotate(-45deg)' }\n                        : null\n                    return (\n                      <HStack\n                        justifySelf='flex-end'\n                        width='100%'\n                        display='flex'\n                        alignItems='center'\n                        justifyContent='flex-end'\n                        key={i}\n                      >\n                        <C_TypeAndValue\n                          fnId={item.id}\n                          paramIndex={i}\n                          direction='column'\n                        />{' '}\n                        <ArrowForwardIcon css={css} />\n                      </HStack>\n                    )\n                  })}\n          </GridItem>\n          <GridItem width='100%'>\n            <VStack>\n              {hasZeroParams ? (\n                <Code>()</Code>\n              ) : (\n                <C_TypeAndValue\n                  fnId={item.id}\n                  paramIndex='last'\n                  direction='column'\n                  noInput={!isFirstFunctionInFlow}\n                />\n              )}\n              <ArrowDownIcon></ArrowDownIcon>\n              <C_TypeAndValue\n                fnId={item.id}\n                noInput\n                paramIndex='return'\n                direction='column'\n              />\n            </VStack>\n          </GridItem>\n        </Grid>\n      )\n    },\n  ),\n)\n\nconst getFnsValuesFromItems = (\n  items: Array<IfunctionWithId>,\n  previousItems: Array<IfunctionWithId> = [],\n) => {\n  let previousReturn = null\n  let newItems: IfunctionWithId[] = []\n\n  for (let i = 0; i < items.length; i++) {\n    const item = previousItems.find(pi => pi.id === items[i].id) ?? items[i]\n    const parameters = [...item.parameters]\n    const previouslastParam: Itype | undefined =\n      parameters[parameters.length - 1]\n    if (previouslastParam) {\n      parameters[parameters.length - 1] = {\n        ...previouslastParam,\n        value:\n          previousReturn === null ? previouslastParam?.value : previousReturn,\n      }\n    }\n\n    //TODO typecheck, show error\n    console.log({ parameters })\n    let returnValue\n    let error\n    try {\n      returnValue = item.fn(...parameters.map(p => p.value))\n    } catch (err) {\n      error = err\n      console.log({ error })\n    }\n\n    console.log('break')\n\n    //TODO only push if no error\n    newItems.push({\n      ...item,\n      parameters,\n      returns: { ...item.returns, value: returnValue },\n    })\n\n    previousReturn = returnValue\n  }\n\n  return newItems\n}\n\nconst ParameterContext = React.createContext<{\n  fns: Array<IfunctionWithId>\n  setFns: React.Dispatch<React.SetStateAction<IfunctionWithId[]>>\n}>({ fns: [], setFns() {} })\n\ntype IfunctionWithId = Ifunction & { id: string }\n\nconst FlowFunctionsList = React.memo(\n  ({ items }: { items: Array<IfunctionWithId> }) => {\n    const [fns, setFns] = React.useState(getFnsValuesFromItems(items))\n    const [previousItems, setPreviousItems] = React.useState(items)\n    if (previousItems !== items) {\n      setPreviousItems(items)\n      setFns(previousValues => getFnsValuesFromItems(items, previousValues))\n    }\n\n    //Recoil?\n    //items deberia venir sin parameter values - se calculan en el setState o en el render? en el setState\n    // que pasa cuando viene una fn nueva?\n    // can FlowFunctionView never reupdate after initial render? not rerender if isFiFIFlow changes\n\n    return (\n      <ParameterContext.Provider value={{ fns, setFns }}>\n        {items.map((item, i) => {\n          return (\n            <Draggable key={item.id} draggableId={item.id} index={i}>\n              {(provided, snapshot) => {\n                return (\n                  <Fade in={true}>\n                    <FlowFunctionView\n                      isFirstFunctionInFlow={i === 0}\n                      item={item}\n                      ref={provided.innerRef}\n                      {...provided.draggableProps}\n                      {...provided.dragHandleProps}\n                      // style={provided.draggableProps.style}\n                    />\n                  </Fade>\n                )\n              }}\n            </Draggable>\n          )\n        })}\n      </ParameterContext.Provider>\n    )\n  },\n)\n\nconst FlowCard = React.memo(\n  ({\n    items,\n    name,\n    dispatch,\n  }: {\n    items: Array<Ifunction & { id: string }>\n    name: string\n    dispatch: React.Dispatch<Action>\n  }) => {\n    return (\n      <Box\n        boxShadow={'base'}\n        padding={1}\n        // width={'49%'}\n        minWidth='48%'\n        minHeight='99vh'\n        height='100%'\n        position='relative'\n        backgroundColor='white'\n        display='flex'\n        flexDirection='column'\n      >\n        <Flex paddingLeft={2} alignItems='center'>\n          <Heading fontSize='xl' fontStyle='italic' color='unison.purple'>\n            Flow\n          </Heading>\n          <Spacer></Spacer>\n\n          <Fade in={items.length > 0}>\n            <Button\n              color='unison.darkPink'\n              sx={{ '&:hover': { backgroundColor: 'red.50' } }}\n              variant='ghost'\n              leftIcon={<DeleteIcon />}\n              onClick={() => {\n                dispatch({ type: 'clearFlowCard' })\n              }}\n            >\n              Clear\n            </Button>\n          </Fade>\n\n          <PopoverExplanation label='Flow card explanation' title='Flow card'>\n            Flow is a special view for the flow function (left-to-right variadic\n            compose). This is a stab at a \"functional Scratch\" to visually\n            explore function composition. Last argument and return type line up\n            vertically to reinforce the pipeline metaphor. JavaScript is\n            executed and shown on the right.\n          </PopoverExplanation>\n        </Flex>\n        <Divider marginTop={2}></Divider>\n        <Droppable droppableId='FlowCard'>\n          {(provided, snapshot) => {\n            return (\n              <Box\n                ref={provided.innerRef}\n                {...provided.droppableProps}\n                // minWidth={'50%'}\n                flex={1}\n                minHeight='100%'\n                height='100%'\n                overflow='auto'\n                paddingX={2}\n                paddingY={4}\n              >\n                <FlowFunctionsList items={items}></FlowFunctionsList>\n                {provided.placeholder}\n              </Box>\n            )\n          }}\n        </Droppable>\n      </Box>\n    )\n  },\n)\n\nexport default FlowCard\n","import * as React from 'react'\nimport { DragDropContext } from 'react-beautiful-dnd'\nimport {\n  Box,\n  Button,\n  Center,\n  ScaleFade,\n  useTheme,\n  useToken,\n} from '@chakra-ui/react'\nimport SideBar from './components/Sidebar'\nimport CardHStack from './components/CardHStack'\nimport SplitPane from 'react-split-pane'\nimport FlowCard from './components/FlowCard'\nimport { StateContext, useAppReducer } from './state'\nimport DocsCard from './components/DocsCard/DocsCard'\nimport { matchSorter } from 'match-sorter'\nimport './styles.css'\nimport { HotKeys } from 'react-hotkeys'\nimport { AddIcon } from '@chakra-ui/icons'\n\nexport const App = () => {\n  const [state, dispatch] = useAppReducer()\n  const onDragEnd = React.useCallback(\n    dropResult => {\n      console.log({ dropResult })\n      if (\n        //SideBar to FlowCard\n        dropResult.source.droppableId !== 'FlowCard' &&\n        dropResult.destination?.droppableId === 'FlowCard'\n      ) {\n        dispatch({\n          type: 'dropFnFromSideBarOnFlowCard',\n          index: dropResult.destination.index,\n          draggableId: dropResult.draggableId,\n        })\n      } else if (\n        // FlowCard to FlowCard\n        dropResult.source.droppableId === 'FlowCard' &&\n        dropResult.destination?.droppableId === 'FlowCard'\n      ) {\n        dispatch({\n          type: 'dropFnFromFlowCardToFlowCard',\n          sourceIndex: dropResult.source.index,\n          destinationIndex: dropResult.destination.index,\n        })\n      } else if (dropResult.destination?.droppableId === 'DocsCard') {\n        dispatch({\n          type: 'dropFnFromSideBarToDocsCard',\n          draggableId: dropResult.draggableId,\n        })\n      } else {\n        dispatch({ type: 'dropOutside' })\n\n        //Regain focus after dropping outside - TODO does not work if dragged and esc pressed\n        const li: any = document.querySelector(\n          `[id$='${dropResult.draggableId}']`,\n        )\n        if (li) {\n          li.focus()\n        }\n      }\n    },\n    [dispatch],\n  )\n  const sideBarRef = React.useRef()\n  const purple = useToken('colors', 'unison.purple')\n\n  return (\n    <StateContext.Provider value={{ state, dispatch }}>\n      <HotKeys //TODO substitute for mousetrap + useEffect\n        keyMap={{ focusSidebar: ['ctrl+b', 'command+b'] }} //TODO parameterize\n        handlers={{\n          focusSidebar() {\n            let a = sideBarRef as any\n            a.current.focus()\n          },\n        }}\n      >\n        <DragDropContext\n          onDragStart={() => {\n            dispatch({ type: 'isDragging' })\n          }}\n          onDragEnd={onDragEnd}\n        >\n          <SplitPane\n            style={{\n              // overflow: 'auto',\n              height: '100vh',\n              borderTop: `6px solid ${purple}`,\n            }}\n            defaultSize='20%'\n            minSize={100}\n            maxSize={-300}\n            split='vertical'\n            pane2Style={{\n              overflowX: 'auto',\n              // overflow: 'auto',\n            }}\n          >\n            <SideBar\n              ref={sideBarRef}\n              searchValue={state.searchValue}\n              dispatch={dispatch}\n              isAnyItemDragging={state.isSideBarItemDragging}\n              items={[\n                {\n                  nodeId: 'functions',\n                  label: 'Functions',\n                  items: matchSorter(state.functions, state.searchValue, {\n                    keys: ['name'],\n                  }),\n                },\n                {\n                  nodeId: 'types',\n                  label: 'Data Types',\n                  items: matchSorter(state.dataTypes, state.searchValue, {\n                    keys: ['type'],\n                  }),\n                },\n                {\n                  nodeId: 'effects',\n                  label: 'Effects',\n                  items: matchSorter(state.effects, state.searchValue, {\n                    keys: ['name'],\n                  }),\n                },\n              ]}\n            ></SideBar>\n            <CardHStack>\n              <FlowCard\n                items={state.flowCardFunctions}\n                dispatch={dispatch}\n                name=''\n              ></FlowCard>\n              {state.docCards.length > 0 ? (\n                state.docCardsNavigationType === 'history' ? (\n                  <DocsCard\n                    index={state.docCardsSelectedIndex}\n                    func={(() => {\n                      const doc = state.docCards[state.docCardsSelectedIndex]\n                      console.log(state.docCards, state.docCardsSelectedIndex)\n                      return doc.type === 'editing'\n                        ? state.functions.find(f => f.name === doc.fnName)\n                        : undefined\n                    })()}\n                    dispatch={dispatch}\n                    functions={state.functions}\n                    navigationType={'history'}\n                  />\n                ) : (\n                  state.docCards.map((doc, i) => {\n                    const func =\n                      doc.type === 'editing'\n                        ? state.functions.find(f => f.name === doc.fnName)\n                        : undefined\n                    return (\n                      <DocsCard\n                        key={i}\n                        index={i}\n                        func={func}\n                        dispatch={dispatch}\n                        functions={state.functions}\n                        navigationType={\n                          i === 0 ? state.docCardsNavigationType : undefined\n                        }\n                      />\n                    )\n                  })\n                )\n              ) : (\n                <Box width={'100%'}>\n                  <Center>\n                    <ScaleFade in={true}>\n                      <Button\n                        leftIcon={<AddIcon />}\n                        colorScheme='teal'\n                        variant='ghost'\n                        fontSize='xl'\n                        onClick={() => dispatch({ type: 'newDocsCard' })}\n                      >\n                        New function\n                      </Button>\n                    </ScaleFade>\n                  </Center>\n                </Box>\n              )}\n              {/* <Card>\n              <form>\n                <InputGroup size='sm'>\n                  <InputLeftAddon>\n                    <Code>function</Code>\n                  </InputLeftAddon>\n                  <Input></Input>\n                  <InputRightAddon>\n                    <Code>(</Code>\n                  </InputRightAddon>\n                </InputGroup>\n                <Menu isOpen={true}>\n                  <MenuButton as={Button}>Type</MenuButton>\n                  <MenuList>\n                    <MenuItem>+ New Type</MenuItem>\n                    <MenuItem>String</MenuItem>\n                    <MenuItem>Number</MenuItem>\n                  </MenuList>\n                </Menu>\n              </form>\n            </Card>\n            <Card>\n              <Editor></Editor>\n            </Card> */}\n            </CardHStack>\n          </SplitPane>\n        </DragDropContext>\n      </HotKeys>\n    </StateContext.Provider>\n  )\n}\n//\"calc(100vh - 3rem)\"\n","import { ReportHandler } from \"web-vitals\"\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n\nexport default reportWebVitals\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://cra.link/PWA\",\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://cra.link/PWA.\",\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It is the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\")\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\")\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\",\n      )\n    })\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister()\n      })\n      .catch((error) => {\n        console.error(error.message)\n      })\n  }\n}\n","import { extendTheme } from '@chakra-ui/react'\n\nconst purple = '#520066'\n\nexport default extendTheme({\n  styles: {\n    global: {\n      html: {\n        backgroundColor: purple,\n        minWidth: '860px',\n        '*:focus': {\n          outline: 'none !important',\n          boxShadow: 'none !important',\n        },\n      },\n    },\n  },\n  number: 3,\n  bool: false,\n  shadows: {\n    outline: 'none',\n  },\n  colors: {\n    unison: {\n      purple,\n      lightPurple: '#8f228f',\n      aqua: '#3cd6b7',\n      limegreen: '#88cc00',\n      green: '#008f30',\n      yellow: '#ffc41f',\n      orange: '#ff8800',\n      pink: '#ff4756',\n      lightblue: '#00adeb',\n      blue: '#0951e0',\n      darkblue: '#00018f',\n      gray: '#616c77',\n      //derived:\n      darkOrange: '#572E00',\n      darkGreen: '#005C1F',\n      darkPink: '#C4333F',\n    },\n  },\n})\n\n/*\ncolors:\n  - name: 'lightpurple'\n    base: '#8f228f'\n  - name: 'purple'\n    base: '#520066'\n\n  - name: 'aqua'\n    base: '#3cd6b7'\n  - name: 'limegreen'\n    base: '#88cc00'\n  - name: 'green'\n    base: '#008f30'\n\n  - name: 'yellow'\n    base: '#ffc41f'\n  - name: 'orange'\n    base: '#ff8800'\n  - name: 'pink'\n    base: '#ff4756'\n\n  - name: 'lightblue'\n    base: '#00adeb'\n  - name: 'blue'\n    base: '#0951e0'\n  - name: 'darkblue'\n    base: '#00018f'\n\n  - name: 'black'\n    base: 'black'\n  - name: 'white'\n    base: 'white'\n  - name: 'gray'\n    base: '#616c77'\n\n\n      \n@import 'data/colors.yml'; // $colors\n\n$tones: (\n  xxx-dark:  ( mix: 'shade', percentage: 80% ),\n  xx-dark:   ( mix: 'shade', percentage: 55% ),\n  x-dark:    ( mix: 'shade', percentage: 45% ),\n  dark:      ( mix: 'shade', percentage: 20% ),\n  mid:       ( mix: 'tint',  percentage: 20% ),\n  light:     ( mix: 'tint',  percentage: 45% ),\n  x-light:   ( mix: 'tint',  percentage: 60% ),\n  xx-light:  ( mix: 'tint',  percentage: 75% ),\n  xxx-light: ( mix: 'tint',  percentage: 90% )\n);\n\n$UCpalettes: generate-palettes($colors, $tones);\n\n@function palette($name, $tone: 'base') {\n  $palette: map-get($UCpalettes, $name);\n  $color: map-get($palette, $tone);\n  @return $color;\n}\n*/\n","import * as React from 'react'\nimport ReactDOM from 'react-dom'\nimport { ColorModeScript, extendTheme, ChakraProvider } from '@chakra-ui/react'\nimport { App } from './App'\nimport reportWebVitals from './reportWebVitals'\nimport * as serviceWorker from './serviceWorker'\nimport theme from './theme'\n\nReactDOM.render(\n  <React.StrictMode>\n    <ColorModeScript />\n    <ChakraProvider theme={theme}>\n      <App />\n    </ChakraProvider>\n  </React.StrictMode>,\n  document.getElementById('root'),\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorker.unregister()\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n","import * as React from 'react'\nimport { Code, CodeProps, TextProps, useTheme } from '@chakra-ui/react'\nimport { Itype } from './interfaces'\n\nconst TypeBadge = ({\n  typeAsString,\n  // fontSize,\n  as,\n  children,\n  rounded,\n}: {\n  typeAsString: Itype['type']\n  // fontSize?: CodeProps['fontSize']\n  as?: CodeProps['as']\n  rounded?: CodeProps['rounded']\n  children?: any\n}) => {\n  // const {\n  //   colors: {\n  //     unison: { orange, yellow },\n  //   },\n  // } = useTheme()\n\n  return (\n    <Code\n      as={as}\n      // fontSize={fontSize}\n      // paddingX={1}\n      // paddingY={0.5}\n      sx={\n        {\n          string: { color: 'unison.darkOrange', backgroundColor: 'yellow.100' },\n          number: {\n            color: 'unison.darkGreen',\n            backgroundColor: 'green.100',\n          },\n          boolean: { color: 'unison.pink', backgroundColor: 'pink.100' },\n          function: { color: 'unison.purple', backgroundColor: 'purple.100' },\n          object: { color: 'black', backgroundColor: 'gray.100' },\n          array: { color: 'black', backgroundColor: 'gray.100' },\n          undefined: { color: 'black', backgroundColor: 'gray.100' },\n          null: { color: 'black', backgroundColor: 'gray.100' },\n        }[typeAsString]\n      }\n      rounded={rounded ?? 'base'}\n    >\n      {children ?? typeAsString}\n    </Code>\n  )\n}\n\nexport default TypeBadge\n","import * as React from 'react'\nimport { Fade, Button, Box, Switch, IconButton, HStack } from '@chakra-ui/react'\nimport {\n  ArrowUpDownIcon,\n  CheckIcon,\n  ChevronLeftIcon,\n  ChevronRightIcon,\n  CloseIcon,\n  DeleteIcon,\n} from '@chakra-ui/icons'\nimport PopoverExplanation from '../PopoverExplanation'\nimport TypeBadge from '../TypeBadge'\nimport { Itype } from '../interfaces'\nimport { FunctionItem } from '../Sidebar'\nimport { GoVersions } from 'react-icons/go'\nimport { Action, StateContext } from '../../state'\nconst { useContext } = React\n\nexport const SaveButton = ({\n  onClick,\n  fadeIn,\n  disabled,\n}: {\n  onClick: () => void\n  fadeIn: boolean\n  disabled: boolean\n}) =>\n  fadeIn ? (\n    <Fade in={true}>\n      {/* Save button */}\n      <Button\n        color={disabled ? 'gray.300' : 'unison.green'}\n        sx={{ '&:hover': { backgroundColor: 'green.50' } }}\n        variant='ghost'\n        leftIcon={<CheckIcon />}\n        disabled={disabled}\n        onClick={onClick}\n      >\n        Save\n      </Button>\n    </Fade>\n  ) : null\n\nexport const ClearButton = ({\n  onClick,\n  fadeIn,\n}: {\n  onClick: () => void\n  fadeIn: boolean\n}) =>\n  fadeIn ? (\n    <Fade in={true}>\n      <Button\n        color='unison.darkPink'\n        sx={{ '&:hover': { backgroundColor: 'red.50' } }}\n        variant='ghost'\n        leftIcon={<DeleteIcon />}\n        onClick={onClick}\n      >\n        Clear\n      </Button>\n    </Fade>\n  ) : null\n\nexport const DocsExplanation = () => (\n  <PopoverExplanation label='Docs card explanation' title='Docs card'>\n    Docs is an editable view of the documentation for a function. The signature\n    input will autocomplete types (string/boolean/number so far) and arrows but\n    will not prevent invalid states, which will disable the \"Save\" button. The\n    description can reference other functions with \"@\" (triggers autocomplete)\n    and navigate to them by clicking on the link. Navigation can be \"browser\n    history style\" or \"panes style\".\n  </PopoverExplanation>\n)\n\nexport const TypeSuggestionList = ({\n  typeSuggestions,\n  selectedIndex,\n  left,\n  top,\n}: {\n  typeSuggestions: {\n    title: Itype['type']\n  }[]\n  selectedIndex: number\n  left: number\n  top: number\n}) => (\n  <Box\n    as='ul'\n    position='fixed'\n    left={left}\n    top={top}\n    listStyleType='none'\n    padding={1}\n    boxShadow='lg'\n    backgroundColor='white'\n    rounded='sm'\n    zIndex={1000}\n  >\n    {typeSuggestions.map((s, i) => (\n      <Box\n        as='li'\n        key={s.title}\n        display='block'\n        textAlign='center'\n        paddingX={1}\n        paddingY={1}\n        backgroundColor={\n          i === selectedIndex\n            ? 'unison.aqua'\n            : s.title === 'string'\n            ? 'yellow.100'\n            : s.title === 'number'\n            ? 'green.100'\n            : s.title === 'boolean'\n            ? 'pink.100'\n            : 'white'\n        }\n      >\n        <TypeBadge rounded={'none'} typeAsString={s.title}>\n          {s.title}\n        </TypeBadge>\n      </Box>\n    ))}\n  </Box>\n)\n\nexport const FunctionSuggestionList = ({\n  functionSuggestions,\n  selectedIndex,\n  left,\n  top,\n}: {\n  functionSuggestions: {\n    name: string\n  }[]\n  selectedIndex: number\n  left: number\n  top: number\n}) => (\n  <Box\n    as='ul'\n    position='fixed'\n    left={left}\n    top={top}\n    listStyleType='none'\n    padding={1}\n    boxShadow='lg'\n    backgroundColor='white'\n    rounded='sm'\n    zIndex={1000}\n  >\n    {functionSuggestions.map((s, i) => (\n      <Box\n        as='li'\n        key={s.name}\n        display='block'\n        textAlign='center'\n        paddingX={1}\n        paddingY={1}\n        backgroundColor={i === selectedIndex ? 'unison.aqua' : 'white'}\n        rounded={'base'}\n      >\n        {s.name}\n      </Box>\n    ))}\n  </Box>\n)\n\nexport const DocsNavigationTypeSelector = ({\n  navigationType,\n  dispatch,\n}: {\n  navigationType: 'history' | 'panes'\n  dispatch: React.Dispatch<Action>\n}) => {\n  return (\n    <IconButton\n      onClick={() => {\n        dispatch({\n          type: 'changeNavigationType',\n          navigationType: navigationType === 'history' ? 'panes' : 'history',\n        })\n      }}\n      variant='ghost'\n      sx={{\n        color: 'unison.purple',\n        '&:hover': {\n          color: 'unison.aqua',\n        },\n      }}\n      aria-label='Change navigation type'\n      size='md'\n      icon={\n        navigationType === 'panes' ? (\n          <ArrowUpDownIcon\n            sx={{ transform: 'rotate(90deg)' }}\n          ></ArrowUpDownIcon>\n        ) : (\n          <GoVersions></GoVersions>\n        )\n      }\n    ></IconButton>\n\n    /* <Switch\n        size='sm'\n        isChecked={navigationType === 'panes'}\n        marginX={1}\n        onChange={() => {\n          dispatch({\n            type: 'changeNavigationType',\n            navigationType: navigationType === 'history' ? 'panes' : 'history',\n          })\n        }}\n      ></Switch> */\n  )\n}\n\nconst getButtonStyles = (isDisabled: boolean) => ({\n  variant: 'ghost',\n  sx: isDisabled\n    ? {\n        color: 'grey.300',\n      }\n    : {\n        color: 'unison.purple',\n        '&:hover': {\n          color: 'unison.aqua',\n        },\n      },\n})\n\nexport const DocsNavigationArrows = () => {\n  const { state, dispatch } = useContext(StateContext)\n  const size = '6'\n  const backDisabled = state.docCardsSelectedIndex === 0\n  const forwardDisabled =\n    state.docCardsSelectedIndex === state.docCards.length - 1\n  return (\n    <HStack>\n      <IconButton\n        onClick={() => {\n          dispatch({\n            type: 'docsNavigate',\n            to: 'back',\n          })\n        }}\n        aria-label='Navigate back'\n        {...getButtonStyles(backDisabled)}\n        disabled={backDisabled}\n        icon={<ChevronLeftIcon w={size} h={size}></ChevronLeftIcon>}\n      ></IconButton>\n\n      <IconButton\n        margin={0}\n        onClick={() => {\n          dispatch({\n            type: 'docsNavigate',\n            to: 'forwards',\n          })\n        }}\n        disabled={forwardDisabled}\n        aria-label='Navigate forwads'\n        {...getButtonStyles(forwardDisabled)}\n        icon={<ChevronRightIcon w={size} h={size}></ChevronRightIcon>}\n      ></IconButton>\n    </HStack>\n  )\n}\n","import { QuestionIcon, QuestionOutlineIcon } from '@chakra-ui/icons'\nimport {\n  Popover,\n  PopoverTrigger,\n  IconButton,\n  PopoverContent,\n  PopoverArrow,\n  PopoverCloseButton,\n  PopoverBody,\n  PopoverHeader,\n  PopoverBodyProps,\n  Tooltip,\n} from '@chakra-ui/react'\nimport React from 'react'\n\nconst PopoverExplanation = (props: {\n  children: PopoverBodyProps['children']\n  label: string\n  title: string\n}) => {\n  return (\n    <Popover>\n      <PopoverTrigger>\n        <IconButton\n          aria-label={props.label}\n          icon={\n            <Tooltip label={props.label} aria-label={props.label} hasArrow>\n              {/* <QuestionOutlineIcon /> */}\n              <QuestionIcon />\n            </Tooltip>\n          }\n          size='lg'\n          // colorScheme='purple'\n          color='unison.purple'\n          variant='ghost'\n          sx={{\n            '&:hover': {\n              color: 'unison.aqua',\n            },\n          }}\n        />\n      </PopoverTrigger>\n\n      {/* <PopoverContent borderColor='unison.purple'> */}\n      <PopoverContent>\n        <PopoverArrow />\n        <PopoverCloseButton />\n        <PopoverHeader>{props.title}</PopoverHeader>\n        <PopoverBody>{props.children}</PopoverBody>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport default PopoverExplanation\n","import produce from 'immer'\nimport * as React from 'react'\nimport { v4 as uuid } from 'uuid'\nimport { Ifunction, Ieffect, Itype } from './components/interfaces'\nimport DocsCard from './components/DocsCard/DocsCard'\n\ntype Reducer<A, B> = (a: A, b: B) => A\n\n/* See https://github.com/jefflombard/use-reducer-logger */\nconst getCurrentTimeFormatted = () => {\n  const currentTime = new Date()\n  const hours = currentTime.getHours()\n  const minutes = currentTime.getMinutes()\n  const seconds = currentTime.getSeconds()\n  const milliseconds = currentTime.getMilliseconds()\n  return `${hours}:${minutes}:${seconds}.${milliseconds}`\n}\nconst useLoggerReducer = <A, B extends { type: string | number }>(\n  reducer: Reducer<A, B>,\n  initialState: A,\n) => {\n  const reducerWithLogger = React.useCallback(\n    (state: A, action: B): A => {\n      const next = reducer(state, action)\n      console.group(\n        `%cAction: %c${action.type} %cat ${getCurrentTimeFormatted()}`,\n        'color: lightgreen; font-weight: bold;',\n        'color: white; font-weight: bold;',\n        'color: lightblue; font-weight: lighter;',\n      )\n      console.log(\n        '%cPrevious State:',\n        'color: #9E9E9E; font-weight: 700;',\n        state,\n      )\n      console.log('%cAction:', 'color: #00A7F7; font-weight: 700;', action)\n      console.log('%cNext State:', 'color: #47B04B; font-weight: 700;', next)\n      console.groupEnd()\n      return next\n    },\n    [reducer],\n  )\n\n  return React.useReducer(reducerWithLogger, initialState)\n}\n\nconst initialFunctions: Array<Ifunction> = [\n  {\n    name: 'length',\n    parameters: [{ type: 'string' }],\n    returns: { type: 'number' },\n    fn: function length(s: any) {\n      return s.length\n    },\n    description: 'Takes a string and returns how many characters it has',\n  },\n  {\n    name: 'upperCase',\n    parameters: [{ type: 'string' }],\n    returns: { type: 'string' },\n    fn: function (s: any) {\n      return s.toUpperCase()\n    },\n    description:\n      'Takes a string and returns is with all characters in uppercase',\n  },\n  {\n    name: 'add',\n    parameters: [{ type: 'number' }, { type: 'number' }],\n    returns: { type: 'number' },\n    fn: function add(x: any, y: any) {\n      return x + y\n    },\n    description: 'Adds two numbers together',\n  },\n  // {\n  //   name: 'map',\n  //   parameters: [\n  //     { type: 'function', parameterName: 'f' },\n  //     { type: 'array', of: { typeParam: 'A' }, parameterName: 'as' },\n  //   ],\n  //   returns: { type: 'array', of: { typeParam: 'B' } },\n  //   code: 'function map(f,as){return as.map(f)}',\n  //   description: 'Applies a function to each element of an array',\n  // },\n  {\n    name: 'id',\n    parameters: [{ type: 'string' }],\n    returns: { type: 'string' },\n    fn: function id(s: any) {\n      return s\n    },\n    description: 'monomorphic id for string',\n  },\n  {\n    name: 'greaterThan',\n    parameters: [{ type: 'number' }, { type: 'number' }],\n    returns: { type: 'boolean' },\n    fn: function greaterThan(n: number, m: number) {\n      return m > n\n    },\n    description: 'Number is greater than another',\n  },\n]\nconst initialDataTypes: Array<Itype> = [\n  { type: 'string' },\n  { type: 'number' },\n  { type: 'boolean' },\n]\nconst initialEffects: Array<Ieffect> = []\n\nexport type Action =\n  | { type: 'isDragging' }\n  | { type: 'createFunction'; function: Ifunction; index: number }\n  | { type: 'dropOutside' }\n  | { type: 'dropFnFromSideBarOnFlowCard'; index: number; draggableId: string }\n  | {\n      type: 'dropFnFromFlowCardToFlowCard'\n      sourceIndex: number\n      destinationIndex: number\n    }\n  | { type: 'clearFlowCard' }\n  | { type: 'sideBarSearch'; value: string }\n  | { type: 'dropFnFromSideBarToDocsCard'; draggableId: string }\n  | { type: 'openDocs'; fnName: string; openerIndex: number }\n  | { type: 'closeDocsCard'; index: number }\n  | { type: 'clearDocsCard'; index: number }\n  | { type: 'newDocsCard' }\n  | { type: 'changeNavigationType'; navigationType: NavigationType }\n  | { type: 'docsNavigate'; to: 'forwards' | 'back' }\n// | {\n//     type: 'changeFunctionParamValue'\n//     paramValue: string | number | boolean\n//     paramIndex: number\n//     functionId: string\n//   }\nexport type NavigationType = 'history' | 'panes'\ntype DocsType = { type: 'creating' } | { type: 'editing'; fnName: string }\n\ntype State = {\n  functions: Ifunction[]\n  dataTypes: Itype[]\n  effects: Ieffect[]\n  isSideBarItemDragging: boolean\n  flowCardFunctions: Array<Ifunction & { id: string }>\n  docCardsNavigationType: NavigationType\n  docCardsSelectedIndex: number\n  docCards: Array<DocsType>\n  searchValue: string\n}\n\nconst initialState: State = {\n  functions: initialFunctions,\n  dataTypes: initialDataTypes,\n  effects: initialEffects,\n  isSideBarItemDragging: false,\n  flowCardFunctions: [],\n  docCardsNavigationType: 'panes',\n  docCardsSelectedIndex: 0,\n  docCards: [\n    { type: 'creating' },\n    { type: 'editing', fnName: 'add' },\n    { type: 'editing', fnName: 'id' },\n  ],\n  searchValue: '',\n}\n\nconst reorder = (list: any[], startIndex: number, endIndex: number) => {\n  const listCopy = [...list]\n  const [removed] = listCopy.splice(startIndex, 1)\n  listCopy.splice(endIndex, 0, removed)\n  return listCopy\n}\nconst insert = <A>(list: Array<A>, index: number, item: A) => {\n  const listCopy = [...list]\n  listCopy.splice(index, 0, item)\n  return listCopy\n}\n\nconst changeAtIndex = <A>(list: Array<A>, index: number, item: A) => {\n  const listCopy = [...list]\n  listCopy.splice(index, 1, item)\n  return listCopy\n}\n\nconst getDefaultValue = (p: Itype) => {\n  return p.type === 'string'\n    ? ''\n    : p.type === 'number'\n    ? 0\n    : p.type === 'boolean'\n    ? false\n    : p.type === 'object'\n    ? ''\n    : p.type === 'undefined'\n    ? undefined\n    : p.type === 'null'\n    ? undefined\n    : ''\n}\nconst findFunction = ({\n  state,\n  name,\n  id,\n}: {\n  state: State\n  name: string\n  id: string\n}) => {\n  const fn = state.functions.find(f => f.name === name) as Ifunction\n  const parameters = fn.parameters.map(p => {\n    const value = getDefaultValue(p)\n    return {\n      ...p,\n      value,\n    }\n  })\n  const returns = { ...fn.returns, value: getDefaultValue(fn.returns) }\n  return { ...fn, parameters, returns, id }\n}\n\n// return {\n//   ...state,\n//   isSideBarItemDragging: false,\n//   flowCardFunctions: insert(state.flowCardFunctions, action.index, {\n//     name: action.draggableId.split('_')[1],\n//     id: uuid(),\n//   }),\n// }\n\n// export const fnSelector = (state: State) => ({\n//   name,\n//   id,\n// }: {\n//   name: string\n//   id: string\n// }) => {\n//   const fn = state.functions.find(f => f.name === name) as Ifunction\n//   return { ...fn, id }\n// }\n\nconst incrementWithinBounds = (i: number, as: any[]) =>\n  i === as.length - 1 ? i : i + 1\nconst decrementPositiveNumber = (i: number) => (i === 0 ? i : i - 1)\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'isDragging':\n      return { ...state, isSideBarItemDragging: true }\n    case 'createFunction':\n      const fnIndex = state.functions.findIndex(\n        f => f.name === action.function.name,\n      )\n      return fnIndex === -1\n        ? {\n            ...state,\n            functions: state.functions.concat(action.function),\n            docCards: changeAtIndex(state.docCards, action.index, {\n              type: 'editing',\n              fnName: action.function.name,\n            }),\n          }\n        : {\n            ...state,\n            functions: changeAtIndex(state.functions, fnIndex, action.function),\n          }\n    case 'dropOutside':\n      return { ...state, isSideBarItemDragging: false }\n    case 'dropFnFromSideBarOnFlowCard':\n      return {\n        ...state,\n        isSideBarItemDragging: false,\n        flowCardFunctions: insert(\n          state.flowCardFunctions,\n          action.index,\n          findFunction({\n            state,\n            name: action.draggableId.split('_')[1],\n            id: uuid(),\n          }),\n        ),\n      }\n    case 'dropFnFromFlowCardToFlowCard':\n      return {\n        ...state,\n        isSideBarItemDragging: false,\n        flowCardFunctions: reorder(\n          state.flowCardFunctions,\n          action.sourceIndex,\n          action.destinationIndex,\n        ),\n      }\n    case 'clearFlowCard':\n      return {\n        ...state,\n        flowCardFunctions: [],\n      }\n    case 'sideBarSearch':\n      return {\n        ...state,\n        searchValue: action.value,\n      }\n    case 'dropFnFromSideBarToDocsCard':\n      return {\n        ...state,\n        docCards: [\n          { type: 'editing', fnName: action.draggableId.split('_')[1] },\n        ],\n        docCardsSelectedIndex: 0,\n      }\n    case 'openDocs': {\n      if (\n        /*fn doesn't exist*/\n        !state.functions.find(f => f.name === action.fnName) ??\n        /* already open */\n        state.docCards.find(\n          d => d.type === 'editing' && d.fnName === action.fnName,\n        )\n      ) {\n        return state\n      }\n      const docCards = state.docCards.slice(0, action.openerIndex + 1).concat({\n        type: 'editing',\n        fnName: action.fnName,\n      })\n      const docCardsSelectedIndex = incrementWithinBounds(\n        state.docCardsSelectedIndex,\n        docCards,\n      )\n      return {\n        ...state,\n        docCardsSelectedIndex,\n        docCards,\n      }\n    }\n    case 'closeDocsCard': {\n      if (state.docCardsNavigationType === 'history') {\n        return {\n          ...state,\n          docCards: [],\n          docCardsSelectedIndex: 0,\n        }\n      }\n      const docCards = state.docCards.filter((_, i) => i !== action.index)\n      const docCardsSelectedIndex = decrementPositiveNumber(\n        state.docCardsSelectedIndex,\n      )\n      return {\n        ...state,\n        docCards,\n        docCardsSelectedIndex,\n      }\n    }\n    case 'clearDocsCard':\n      return {\n        ...state,\n        docCards: changeAtIndex(state.docCards, action.index, {\n          type: 'creating',\n        }),\n      }\n    case 'newDocsCard':\n      return {\n        ...state,\n        docCards: [{ type: 'creating' }],\n      }\n    case 'changeNavigationType':\n      return {\n        ...state,\n        docCardsNavigationType: action.navigationType,\n        docCardsSelectedIndex: state.docCards.length - 1,\n      }\n    case 'docsNavigate': {\n      const docCardsSelectedIndex =\n        action.to === 'forwards'\n          ? incrementWithinBounds(state.docCardsSelectedIndex, state.docCards)\n          : decrementPositiveNumber(state.docCardsSelectedIndex)\n\n      return {\n        ...state,\n        docCardsSelectedIndex,\n      }\n    }\n  }\n}\n\nexport const StateContext = React.createContext<{\n  state: State\n  dispatch: React.Dispatch<Action>\n}>({ state: initialState, dispatch() {} })\n\nexport const useAppReducer =\n  process.env.NODE_ENV === 'development'\n    ? () => useLoggerReducer(reducer, initialState)\n    : () => React.useReducer(reducer, initialState)\n"],"sourceRoot":""}